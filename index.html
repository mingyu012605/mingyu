<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI VR CAD Editor</title>
    <!-- Using Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Global Styles */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            /* Authentic Fusion-like pure white background for the whole app */
            background-color: #FFFFFF; /* Pure white base color for Fusion 360 */
            background-image: repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(0,0,0,0.1) 20px), /* Visible darker grid lines */
            repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(0,0,0,0.1) 20px);
            background-size: 20px 20px; /* Size of each grid cell */
            overflow: hidden; /* Keep overflow hidden for main body */
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            background-color: #1a202c; /* Darker, more professional header */
            padding: 15px 25px;
            color: #e2e8f0; /* Lighter text for contrast */
            text-align: center;
            font-size: 2.2rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-shrink: 0;
            height: 70px;
            box-sizing: border-box;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            position: relative; /* For API key status positioning */
        }

            header svg {
                height: 35px;
                width: 35px;
                fill: #DAA520; /* Accent color for the logo - Dark Yellow */
                transition: transform 0.3s ease;
            }

            header:hover svg {
                transform: rotate(5deg) scale(1.05);
            }

        /* Page Container & Transitions */
        .page-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            width: 100%;
            position: relative;
        }

        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.6s ease-in-out, transform 0.6s ease-in-out;
            transform: translateX(0);
        }

        .page-active {
            opacity: 1;
            pointer-events: auto !important; /* Ensure it's clickable */
            z-index: 1;
        }

        .page-inactive {
            opacity: 0;
            pointer-events: none;
            z-index: 0;
            transform: translateX(-100%);
        }

        /* Upload Page */
        #uploadPage {
            background-color: transparent; /* Changed to transparent to show body background */
            color: #333;
            padding: 20px;
            box-sizing: border-box;
        }

        .upload-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            background: #ffffff;
            padding: 50px 60px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 500px;
            text-align: center;
        }

            .upload-content h2 {
                color: #1a202c;
                margin-bottom: 15px;
                font-size: 2.2em;
                font-weight: 700;
                display: flex; /* Enable flex for logo and text alignment */
                align-items: center;
                justify-content: center;
                gap: 10px; /* Space between logo and text */
            }

                .upload-content h2 svg {
                    height: 35px;
                    width: 35px;
                    fill: #DAA520; /* Accent color for the logo - Dark Yellow */
                }


        #dropZone {
            width: 100%;
            height: 180px;
            border: 3px dashed #a0aec0;
            border-radius: 10px;
            /* FIX: pointer-events and display are now controlled solely by JS for clarity */
            display: none; /* Initially hidden */
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #4a5568;
            cursor: pointer;
            transition: border-color 0.4s ease, background-color 0.4s ease, color 0.4s ease;
            font-size: 1.2em;
            background-color: #f7fafc;
            font-weight: 600;
            position: relative; /* Keep relative for internal positioning if needed later */
            overflow: hidden;
            /* Removed initial pointer-events: none; from CSS, controlled by JS */
        }

            #dropZone:hover {
                border-color: #DAA520; /* Accent color on hover - Dark Yellow */
                background-color: #FFF8DC; /* Light yellow background on hover */
                color: #B8860B; /* Darker yellow text */
            }

        /* fileInput is now handled by inline style and pointer-events on dropZone */

        .button-group {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            gap: 15px; /* Space between buttons */
            margin-top: 25px;
            width: 100%; /* Ensure buttons take full width of upload-content */
        }

        .button {
            padding: 14px 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 100%; /* Make buttons full width */
            box-sizing: border-box; /* Include padding in width */
            pointer-events: auto; /* Ensure buttons are always clickable */
        }

            .button.primary {
                background-color: #DAA520; /* Primary button - Dark Yellow */
                color: white;
            }

                .button.primary:hover {
                    background-color: #B8860B; /* Darker yellow on hover */
                    transform: translateY(-3px);
                    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
                }

            .button.secondary {
                background-color: #6c757d;
                color: white;
            }

                .button.secondary:hover {
                    background-color: #5a6268;
                    transform: translateY(-3px);
                    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
                }

        #loadingMsg {
            display: none;
            margin-top: 25px;
            color: #DAA520; /* Dark Yellow */
            font-size: 1.15em;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            pointer-events: none; /* FIX: Ensure loading message is non-interactive */
        }

        /* Editor Page */
        #editorPage {
            background-color: #FFFFFF; /* Pure white background - authentic Fusion */
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: stretch;
            padding: 0;
            box-sizing: border-box;
            flex-grow: 1; /* Ensure editor page takes full height after header */
        }

        /* Right Panel for Chat and Code Editor */
        .right-panel {
            width: 350px; /* Fixed width for the sidebar */
            min-width: 300px; /* Ensure it doesn't get too small */
            background-color: #1a202c;
            padding: 25px;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #2d3748;
            box-shadow: -4px 0 10px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
            color: #e2e8f0;
            height: 100%; /* Ensure right-panel takes full available height */
            box-sizing: border-box; /* Include padding in height calculation */
        }

            .right-panel h2 {
                color: #ffffff;
                margin-bottom: 25px;
                font-size: 1.9em;
                border-bottom: 2px solid #DAA520; /* Accent color border - Dark Yellow */
                padding-bottom: 12px;
                font-weight: 700;
            }

        /* Tab buttons for chat/code editor */
        .tab-buttons {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden;
            background-color: #2d3748;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            padding: 5px;
            box-sizing: border-box;
            gap: 5px;
        }

        .tab-button {
            flex-grow: 1;
            padding: 10px 15px;
            border: none;
            background-color: transparent;
            color: #a0aec0;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
            text-align: center;
            border-radius: 8px;
        }

            .tab-button:hover {
                background-color: #3a414e;
                color: #e2e8f0;
            }

            .tab-button.active {
                background-color: #DAA520;
                color: white;
                box-shadow: 0 2px 5px rgba(218, 165, 32, 0.3);
            }

        /* Small circular button for "Back to Upload" */
        #backToUploadCircleButton {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #DAA520;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
            flex-shrink: 0;
        }

            #backToUploadCircleButton:hover {
                background-color: #B8860B;
                transform: translateY(-2px);
                box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
            }

            #backToUploadCircleButton svg {
                fill: #FFFFFF;
                height: 20px;
                width: 20px;
            }


        /* Tab content areas */
        .tab-content {
            flex-grow: 1;
            display: none;
            flex-direction: column;
            padding-top: 5px;
            height: 100%;
            box-sizing: border-box;
        }

            .tab-content.active {
                display: flex;
            }

        #chatContent {
            /* No changes needed here, as parent .tab-content and children #aiLog and .ai-input-group handle flex distribution */
        }

        #codeEditorContent {
            height: 100%;
        }

        #cadViewer {
            flex-grow: 1;
            background-color: #FFFFFF;
            position: relative;
        }

        #cadCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #aiLog {
            flex-grow: 1;
            flex-shrink: 1;
            background-color: #2d3748;
            border-radius: 10px;
            padding: 15px;
            color: #e2e8f0;
            overflow-y: auto;
            line-height: 1.5;
            margin-bottom: 10px;
            min-height: 50px;
            flex-basis: 0;
        }

        .user-message, .ai-response, .system-message {
            padding: 8px 12px;
            border-radius: 12px;
            margin-bottom: 8px;
            word-wrap: break-word;
            max-width: 85%;
        }

        .user-message {
            background-color: #DAA520;
            color: white;
            text-align: right;
            align-self: flex-end;
            margin-left: auto;
        }

        .ai-response {
            background-color: #4a5568;
            color: #e2e8f0;
            text-align: left;
            align-self: flex-start;
            margin-right: auto;
        }

        .system-message {
            background-color: #2d3748;
            color: #cbd5e0;
            text-align: center;
            font-style: italic;
            border-bottom: 1px dashed #4a5568;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        /* Updated AI Input Group for integrated voice button */
        .ai-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
            padding-top: 10px;
            box-sizing: border-box;
            position: sticky;
            bottom: 0;
            background-color: #1a202c;
            z-index: 10;
            padding-bottom: 10px;
        }

        #textCommandInput {
            flex-grow: 1;
            padding: 12px;
            border: 1px solid #4a5568;
            border-radius: 25px;
            background-color: #2d3748;
            color: #e2e8f0;
            font-size: 1em;
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

            #textCommandInput::placeholder {
                color: #a0aec0;
            }

            #textCommandInput:focus {
                border-color: #DAA520;
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 0 2px rgba(218, 165, 32, 0.3);
            }

        #sendTextCommandBtn {
            padding: 12px 20px;
            background-color: #DAA520;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

            #sendTextCommandBtn:hover {
                background-color: #B8860B;
                transform: translateY(-2px);
                box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
            }

        /* New style for the integrated microphone button (now a separate button) */
        #integratedVoiceBtn {
            background-color: #3a414e;
            border: none;
            cursor: pointer;
            padding: 10px;
            border-radius: 50%;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 48px;
            width: 48px;
            box-sizing: border-box;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

            #integratedVoiceBtn svg {
                fill: #FFFFFF;
                height: 24px;
                width: 24px;
                transition: fill 0.3s ease;
            }

            #integratedVoiceBtn:hover {
                background-color: #4a5568;
                transform: translateY(-2px);
                box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            }

                #integratedVoiceBtn.active-voice-btn {
                    background-color: #e53e3e;
                    box-shadow: 0 0 0 4px rgba(229, 62, 62, 0.4);
                }

                #integratedVoiceBtn.active-voice-btn svg {
                    fill: white;
                }

        /* Code Editor Specific Styles */
        #cssCodeEditor {
            width: 100%;
            flex-grow: 1;
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Monaspace Neon', 'Fira Code', 'Consolas', monospace;
            font-size: 0.9em;
            color: #e2e8f0;
            resize: vertical;
            min-height: 150px;
            box-sizing: border-box;
            margin-bottom: 15px;
            outline: none;
        }

            #cssCodeEditor:focus {
                border-color: #DAA520;
                box-shadow: 0 0 0 2px rgba(218, 165, 32, 0.3);
            }

        #applyCssButton {
            width: 100%;
            padding: 12px 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

            #applyCssButton:hover {
                background-color: #218838;
                transform: translateY(-2px);
                box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
            }

        /* New View Controls Section - REMOVED */
        /* .view-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #2d3748;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .view-control-button {
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .view-control-button:hover {
            background-color: #DAA520;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        } */

        /* Style for the static view axes helper */
        #viewAxesContainer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            z-index: 5;
            pointer-events: auto;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
        }

        /* Object Properties Section Styles */
        .object-properties-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #2d3748;
            display: flex;
            flex-direction: column;
            gap: 10px;
            color: #e2e8f0;
        }

        .object-properties-controls h3 {
            color: #ffffff;
            margin-bottom: 10px;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 5px;
        }

        .object-properties-controls .property-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .object-properties-controls label {
            flex-shrink: 0;
            font-weight: 600;
        }

        #objectColorPicker {
            flex-grow: 1;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 80px;
            height: 35px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            overflow: hidden;
        }

        #objectColorPicker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        #objectColorPicker::-webkit-color-swatch {
            border: 1px solid #4a5568;
            border-radius: 5px;
        }

        #objectColorPicker::-moz-color-swatch-wrapper {
            padding: 0;
        }

        #objectColorPicker::-moz-color-swatch {
            border: 1px solid #4a5568;
            border-radius: 5px;
        }

        #applyObjectColorBtn {
            /* Reuse view-control-button styles */
            padding: 8px 15px;
            font-size: 0.9em;
        }
    </style>
    <!-- Import Map for ES Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <header>
        <!-- New Innovative Logo SVG -->
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 1L2 6v12l10 5 10-5V6L12 1zm0 2.31L18.47 6 12 9.31 5.53 6 12 3.31zM4 7.69l6 3.15v6.52L4 13.84V7.69zm8 11.01L6.47 16 12 12.69l5.53 3.31L12 18.7zM20 13.84l-6 3.15V10.84l6-3.15v6.15z" />
            <circle cx="12" cy="12" r="2" fill="#DAA520" /> <!-- Dark Yellow -->
            <path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" fill="#fff" />
        </svg>
        AI VR CAD Editor
        <!-- Removed API Key Status Indicator -->
    </header>

    <div class="page-container">
        <section id="uploadPage" class="page page-active">
            <div class="upload-content">
                <h2>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 1L2 6v12l10 5 10-5V6L12 1zm0 2.31L18.47 6 12 9.31 5.53 6 12 3.31zM4 7.69l6 3.15v6.52L4 13.84V7.69zm8 11.01L6.47 16 12 12.69l5.53 3.31L12 18.7zM20 13.84l-6 3.15V10.84l6-3.15v6.15z" />
                        <circle cx="12" cy="12" r="2" fill="#DAA520" />
                        <path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" fill="#fff" />
                    </svg>
                    AI VR CAD Editor
                </h2>
                <div class="button-group">
                    <button class="button primary" id="createNewEmptyModelButton">Create Empty Model</button>
                    <button class="button primary" id="editExistingModelButton">Edit Existing Model</button>
                    <button class="button secondary" id="loadRandomModelButton">Load Random Model</button>
                </div>
                <div id="dropZone">
                    Drag and Drop your .gltf or .glb file(s) here
                </div>
                <p id="loadingMsg">Loading model, please wait...</p>
                <!-- The file input is kept here, hidden, as it's triggered programmatically -->
                <input type="file" id="fileInput" accept=".gltf,.glb" style="display: none;" />
            </div>
        </section>

        <section id="editorPage" class="page page-inactive">
            <main id="cadViewer">
                <canvas id="cadCanvas"></canvas>
                <div id="viewAxesContainer"></div> <!-- Container for the static view axes -->
            </main>

            <!-- NEW: Right-side chat panel with updated buttons -->
            <div class="right-panel">
                <div class="tab-buttons">
                    <!-- Small circular "Back to Upload" button -->
                    <button id="backToUploadCircleButton" onclick="window.goBack()">
                        <!-- Left arrow SVG -->
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#FFFFFF"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z" /></svg>
                    </button>
                    <button class="tab-button active" id="chatTabButton">AI Chat</button>
                    <button class="tab-button" id="codeEditorTabButton">Code Editor</button>
                    <button class="tab-button" id="uploadNewFileButton">Add New Model</button>
                    <button class="tab-button" id="saveButton">Save Scene</button>
                </div>

                <!-- NEW: Undo/Redo Buttons -->
                <div class="undo-redo-buttons">
                    <button id="undoButton">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#FFFFFF"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.61-3.61c1.39-1.16 3.16-1.89 5.11-1.89 3.73 0 6.84 2.55 7.73 6h2.08c-.9-4.5-4.77-8-9.81-8z"/></svg>
                    </button>
                    <button id="redoButton">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#FFFFFF"><path d="M18.41 16.59L22 13V4h-9l3.61 3.61c-1.39 1.16-3.16 1.89-5.11 1.89-3.73 0-6.84-2.55-7.73-6H2.27c.9 4.5 4.77 8 9.81 8 2.65 0 5.05-.99 6.9-2.6z"/></svg>
                    </button>
                </div>

                <!-- Object Properties Section -->
                <div class="object-properties-controls">
                    <h3>Object Properties</h3>
                    <div class="property-group">
                        <label for="objectColorPicker">Color:</label>
                        <input type="color" id="objectColorPicker" value="#1e90ff" />
                        <button class="view-control-button" id="applyObjectColorBtn">Apply Color</button>
                    </div>
                    <!-- More properties can be added here later -->
                </div>

                <!-- Chat Content remains visible by default -->
                <div id="chatContent" class="tab-content active">
                    <div id="aiLog">
                        <p class="system-message">System: AI Chat Log Initialized.</p>
                    </div>
                    <div class="ai-input-group">
                        <input type="text" id="textCommandInput" placeholder="Type AI command or question..." />
                        <button id="integratedVoiceBtn">
                            <!-- Changed fill to white for visibility -->
                            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#FFFFFF"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.2-3c0 3.53-2.64 6.44-6.2 6.93V21h-2v-3.07c-3.56-.49-6.2-3.4-6.2-6.93h-2c0 4.17 3.13 7.62 7.2 8.15V23h4v-2.85c4.07-.53 7.2-3.98 7.2-8.15h-2z" /></svg>
                        </button>
                        <button id="sendTextCommandBtn">Send</button>
                    </div>
                </div>

                <!-- Code Editor Content is now hidden by default without a direct button -->
                <div id="codeEditorContent" class="tab-content">
                    <textarea id="cssCodeEditor" placeholder="Enter CSS for CAD viewer background..."></textarea>
                    <button id="applyCssButton">Preview CSS</button>
                </div>
            </div>
        </section>
    </div>

    <script type="module">
        // Import Three.js and its modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // Global map to store dropped files by their relative path (e.g., "scene.bin", "textures/image.png")
        const droppedFileBlobs = new Map();

        // List of random GLB model URLs
        const RANDOM_MODEL_URLS = [
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Box/glTF-Binary/Box.glb',
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb',
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb',
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Avocado/glTF-Binary/Avocado.glb',
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb'
        ];

        let uploadedFile = null, scene, camera, renderer, controls;
        let recognition;
        let synth;
        let isVoiceAssistActive = false;
        let raycaster;
        let mouse;
        let selectedObject = null; // This will hold the currently selected THREE.Mesh part
        // Stores original material properties for deselection, now includes color and emissive
        // Changed to store an array of properties for multi-material objects
        const originalMaterialProperties = new Map(); // Stores { uuid: [originalMaterial1, originalMaterial2, ...] or originalMaterial }
        // New map to store original materials for "select all" highlight
        const allHighlightsOriginalMaterials = new Map(); // Stores { uuid: [originalMaterial1, originalMaterial2, ...] or originalMaterial }
        // NEW: This array will hold the actual objects selected by "select all" for functional editing
        let currentlySelectedObjectsForEditing = [];

        let transformControls;

        // Variables for dynamic grid
        let currentGridHelper = null;
        let currentGridLabels = [];

        // Global array to store all loaded GLTF scenes
        let loadedModels = []; // This will now hold all top-level GLTF scenes

        // --- Undo/Redo History ---
        let history = [];
        let historyPointer = -1;
        const MAX_HISTORY_SIZE = 20; // Limit history size to prevent excessive memory usage

        // New scene and camera for the static view axes helper
        let viewAxesScene, viewAxesCamera, viewAxesRenderer;
        let viewAxesHelper; // The actual AxesHelper object
        let viewAxesSceneRendered = false; // Flag to ensure helper is initialized only once

        // Get references to HTML elements
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const loadingMsg = document.getElementById('loadingMsg');
        const uploadPage = document.getElementById('uploadPage');
        const editorPage = document.getElementById('editorPage');
        const integratedVoiceBtn = document.getElementById('integratedVoiceBtn');
        const aiLog = document.getElementById('aiLog');
        const textCommandInput = document.getElementById('textCommandInput');
        const sendTextCommandBtn = document.getElementById('sendTextCommandBtn');
        const cadCanvas = document.getElementById('cadCanvas');
        const cadViewer = document.getElementById('cadViewer'); // Reference to the cadViewer div
        const viewAxesContainer = document.getElementById('viewAxesContainer'); // Container for the static view axes

        // New button references on the upload page
        const loadRandomModelButton = document.getElementById('loadRandomModelButton');
        const createNewEmptyModelButton = document.getElementById('createNewEmptyModelButton');
        const editExistingModelButton = document.getElementById('editExistingModelButton');

        // Updated button references on editor page
        const uploadNewFileButton = document.getElementById('uploadNewFileButton');
        const saveButton = document.getElementById('saveButton');
        const undoButton = document.getElementById('undoButton'); // New Undo button
        const redoButton = document.getElementById('redoButton'); // New Redo button
        const chatContent = document.getElementById('chatContent');
        const codeEditorContent = document.getElementById('codeEditorContent');
        const cssCodeEditor = document.getElementById('cssCodeEditor');
        const applyCssButton = document.getElementById('applyCssButton');

        // NEW: References to tab buttons for setActiveTab function
        const chatTabButton = document.getElementById('chatTabButton');
        const codeEditorTabButton = document.getElementById('codeEditorTabButton');


        // New view control buttons - these are now unused in the HTML but kept for reference if AI commands use them
        const topViewBtn = document.getElementById('topViewBtn');
        const bottomViewBtn = document.getElementById('bottomViewBtn');
        const frontViewBtn = document.getElementById('frontViewBtn');
        const backViewBtn = document.getElementById('backViewBtn');
        const rightViewBtn = document.getElementById('rightViewBtn');
        const leftViewBtn = document.getElementById('leftViewBtn');
        const isometricViewBtn = document.getElementById('isometricViewBtn');
        const fitAllViewBtn = document.getElementById('fitAllViewBtn');

        // New object properties UI elements
        const objectColorPicker = document.getElementById('objectColorPicker');
        const applyObjectColorBtn = document.getElementById('applyObjectColorBtn');

        // Debugging: Raycast hit visualizer
        let raycastDebugSphere;


        // --- Expose functions globally for HTML onclick attributes ---
        window.removeObject = removeObject;
        window.resetView = resetView;
        window.showDesignInfo = showDesignInfo;
        window.goBack = goBack;
        window.selectPartByName = selectPartByName;
        window.setTransformMode = setTransformMode;
        window.listParts = listParts;
        window.saveModel = saveModel; // Expose saveModel globally
        window.highlightAllModels = highlightAllModels; // Expose for AI command
        window.clearAllHighlights = clearAllHighlights; // Expose for AI command
        window.duplicateSelectedObject = duplicateSelectedObject; // Expose for AI command

        // --- Event Listeners for new buttons ---
        // The "Upload New File" button now directly triggers the file input click
        uploadNewFileButton.addEventListener('click', () => {
            console.log("[Upload New File] button clicked."); // Debug log
            fileInput.click(); // Programmatically click the hidden file input
            addMessageToLog('System', 'Clicking "Upload New File" will open file dialog to add another model to the scene.');
        });
        saveButton.addEventListener('click', () => {
            console.log("[Save] button clicked."); // Debug log
            saveModel();
        });

        // --- New Event Listeners for Upload Page Buttons ---
        loadRandomModelButton.addEventListener('click', () => {
            console.log("[Load Random Model] button clicked. Calling goToEditor('random')."); // Added log
            uploadedFile = null; // Ensure no previous file is considered for explicit upload
            goToEditor('random'); // Go to editor and load a random model
        });

        createNewEmptyModelButton.addEventListener('click', () => {
            console.log("[Create Empty Model] button clicked. Calling goToEditor('empty')."); // Added log
            uploadedFile = null; // Ensure no previous file is considered
            goToEditor('empty'); // Go to editor with an empty scene
        });

        editExistingModelButton.addEventListener('click', () => {
            console.log("[Edit Existing Model] button clicked. Opening file dialog."); // Log for debugging
            // Do NOT show dropZone or loadingMsg here. The fileInput 'change' listener will handle cleanup.
            fileInput.click(); // Programmatically click the hidden file input
            addMessageToLog('System', 'Please select a .gltf or .glb file.');
        });

        // --- Undo/Redo Functions ---
        // Function to save the current state of the scene
        function saveSceneState() {
            // Clear any redo history if a new action is performed
            if (historyPointer < history.length - 1) {
                history = history.slice(0, historyPointer + 1);
            }

            const currentState = [];
            loadedModels.forEach(model => {
                const modelState = {
                    uuid: model.uuid, // Store UUID to identify the object when restoring
                    name: model.name,
                    type: model.type, // e.g., Group, Mesh
                    position: model.position.toArray(),
                    rotation: model.rotation.toArray(),
                    scale: model.scale.toArray(),
                    // Store original file data if it's an uploaded model
                    isFileModel: model.userData.isFileModel || false,
                    fileData: model.userData.fileData || null, // Store original file blob or URL
                    // Store primitive type if it's a created primitive
                    isPrimitive: model.userData.isPrimitive || false,
                    primitiveType: model.userData.primitiveType || null,
                    // Store material properties for meshes within this model
                    materials: []
                };

                model.traverse(obj => {
                    if (obj.isMesh && obj.material) {
                        const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                        const initialMaterials = obj.userData.initialMaterial ? (Array.isArray(obj.userData.initialMaterial) ? obj.userData.initialMaterial : [obj.userData.initialMaterial]) : null;

                        const materialStates = materials.map((mat, index) => {
                            const matState = {
                                uuid: mat.uuid,
                                color: mat.color ? mat.color.getHex() : null,
                                emissive: mat.emissive ? mat.emissive.getHex() : null,
                                emissiveIntensity: mat.emissiveIntensity !== undefined ? mat.emissiveIntensity : null,
                                // Add other relevant material properties if needed (e.g., roughness, metalness)
                            };
                            // If there's an initial material, store its properties too for true reversion
                            if (initialMaterials && initialMaterials[index]) {
                                matState.initialColor = initialMaterials[index].color ? initialMaterials[index].color.getHex() : null;
                                matState.initialEmissive = initialMaterials[index].emissive ? initialMaterials[index].emissive.getHex() : null;
                                matState.initialEmissiveIntensity = initialMaterials[index].emissiveIntensity !== undefined ? initialMaterials[index].emissiveIntensity : null;
                            }
                            return matState;
                        });
                        modelState.materials.push({ meshUuid: obj.uuid, states: materialStates });
                    }
                });
                currentState.push(modelState);
            });

            history.push(currentState);
            historyPointer = history.length - 1;

            // Trim history if it exceeds max size
            if (history.length > MAX_HISTORY_SIZE) {
                history.shift(); // Remove the oldest state
                historyPointer--; // Adjust pointer
            }

            console.log(`[History] Saved state. History size: ${history.length}, Pointer: ${historyPointer}`);
            updateUndoRedoButtons();
        }

        // Function to load a specific state from history
        async function loadSceneState(state) {
            console.log("[History] Loading scene state...", state);

            // Dispose current scene objects (excluding grid and axes helpers)
            // Iterate over a copy of the loadedModels array to avoid issues during removal
            const currentLoadedModels = [...loadedModels];
            currentLoadedModels.forEach(model => {
                scene.remove(model);
                model.traverse(child => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
            });
            loadedModels = []; // Clear current loaded models array after removal

            // Clear selection and highlights before loading new state
            clearSelection();
            clearAllHighlights();

            // Recreate objects from the saved state
            for (const modelState of state) {
                let newObject;
                if (modelState.isPrimitive) {
                    // Recreate primitive
                    const material = new THREE.MeshStandardMaterial({ color: 0x1e90ff, metalness: 0.5, roughness: 0.5 });
                    switch (modelState.primitiveType.toLowerCase()) {
                        case 'box': case 'cube': newObject = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), material); break;
                        case 'sphere': case 'ball': newObject = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), material); break;
                        case 'cylinder': case 'tube': newObject = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1, 32), material); break;
                        case 'cone': newObject = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1, 32), material); break;
                        case 'pyramid': newObject = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1, 4), material); break;
                        case 'plane': newObject = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide })); break;
                        case 'torus': newObject = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.2, 16, 100), material); break;
                        default: console.warn(`[loadSceneState] Unknown primitive type: ${modelState.primitiveType}`); continue;
                    }
                    newObject.name = modelState.name;
                    newObject.userData.isPrimitive = true;
                    newObject.userData.primitiveType = modelState.primitiveType;
                } else if (modelState.isFileModel && modelState.fileData) {
                    // Reload GLTF model if it was an uploaded file
                    const loader = new GLTFLoader();
                    try {
                        const file = droppedFileBlobs.get(modelState.fileData.name); // Assuming fileData.name is the key
                        if (file) {
                            const fileUrl = URL.createObjectURL(file);
                            const gltf = await new Promise((resolve, reject) => loader.load(fileUrl, resolve, undefined, reject));
                            newObject = gltf.scene;
                            newObject.name = modelState.name;
                            newObject.userData.isFileModel = true;
                            newObject.userData.fileData = modelState.fileData;
                            URL.revokeObjectURL(fileUrl); // Clean up blob URL
                        } else {
                            console.warn(`[loadSceneState] File data not found for model: ${modelState.name}. Skipping.`);
                            continue;
                        }
                    } catch (error) {
                        console.error(`[loadSceneState] Error reloading GLTF model ${modelState.name}:`, error);
                        continue;
                    }
                } else {
                    console.warn(`[loadSceneState] Cannot restore object type: ${modelState.type || 'unknown'}. Skipping.`);
                    continue;
                }

                // Restore UUID to match the saved state, important for maps like originalMaterialProperties
                newObject.uuid = modelState.uuid;

                // Apply saved transforms
                newObject.position.fromArray(modelState.position);
                newObject.rotation.fromArray(modelState.rotation);
                newObject.scale.fromArray(modelState.scale);

                // Apply saved materials (traverse children to find meshes)
                newObject.traverse(child => {
                    if (child.isMesh && child.material) {
                        const savedMeshMaterials = modelState.materials.find(m => m.meshUuid === child.uuid);
                        if (savedMeshMaterials) {
                            const materials = Array.isArray(child.material) ? child.material : [child.material];
                            savedMeshMaterials.states.forEach((matState, index) => {
                                if (materials[index]) {
                                    // Dispose existing material before replacing with a new one from state
                                    materials[index].dispose();

                                    // Create a new material instance for the child mesh
                                    let restoredMaterial;
                                    // Try to match the original material type if possible
                                    if (materials[index].isMeshStandardMaterial) {
                                        restoredMaterial = new THREE.MeshStandardMaterial();
                                    } else if (materials[index].isMeshBasicMaterial) {
                                        restoredMaterial = new THREE.MeshBasicMaterial();
                                    } else {
                                        restoredMaterial = new THREE.Material(); // Fallback
                                    }

                                    if (matState.color !== null) restoredMaterial.color.setHex(matState.color);
                                    if (matState.emissive !== null) restoredMaterial.emissive.setHex(matState.emissive);
                                    if (matState.emissiveIntensity !== null) restoredMaterial.emissiveIntensity = matState.emissiveIntensity;
                                    restoredMaterial.needsUpdate = true;

                                    if (Array.isArray(child.material)) {
                                        child.material[index] = restoredMaterial;
                                    } else {
                                        child.material = restoredMaterial;
                                    }

                                    // Restore initialMaterial for this child mesh
                                    if (matState.initialColor !== null || matState.initialEmissive !== null) {
                                        let initialMatClone;
                                        if (restoredMaterial.isMeshStandardMaterial) {
                                            initialMatClone = new THREE.MeshStandardMaterial();
                                        } else if (restoredMaterial.isMeshBasicMaterial) {
                                            initialMatClone = new THREE.MeshBasicMaterial();
                                        } else {
                                            initialMatClone = new THREE.Material();
                                        }
                                        if (matState.initialColor !== null) initialMatClone.color.setHex(matState.initialColor);
                                        if (matState.initialEmissive !== null) initialMatClone.emissive.setHex(matState.initialEmissive);
                                        if (matState.initialEmissiveIntensity !== null) initialMatClone.emissiveIntensity = matState.initialEmissiveIntensity;

                                        if (Array.isArray(child.userData.initialMaterial)) {
                                            if (!child.userData.initialMaterial) child.userData.initialMaterial = [];
                                            child.userData.initialMaterial[index] = initialMatClone;
                                        } else {
                                            child.userData.initialMaterial = initialMatClone;
                                        }
                                    }
                                }
                            });
                        }
                    }
                });

                scene.add(newObject);
                loadedModels.push(newObject); // Add to loadedModels array
            }

            // Reset camera to fit the new scene
            resetView(); // This will also update the grid

            console.log("[History] Scene state loaded successfully.");
        }

        // Function to handle Undo
        function undo() {
            if (historyPointer > 0) {
                historyPointer--;
                loadSceneState(history[historyPointer]);
                addMessageToLog('System', `Undid last action. History state: ${historyPointer + 1}/${history.length}`);
                speakResponse('Action undone.');
            } else {
                addMessageToLog('System', 'No more actions to undo.');
                speakResponse('Nothing to undo.');
            }
            updateUndoRedoButtons();
        }

        // Function to handle Redo
        function redo() {
            if (historyPointer < history.length - 1) {
                historyPointer++;
                loadSceneState(history[historyPointer]);
                addMessageToLog('System', `Redid action. History state: ${historyPointer + 1}/${history.length}`);
                speakResponse('Action redone.');
            } else {
                addMessageToLog('System', 'No more actions to redo.');
                speakResponse('Nothing to redo.');
            }
            updateUndoRedoButtons();
        }

        // Function to update the disabled state of Undo/Redo buttons
        function updateUndoRedoButtons() {
            undoButton.disabled = historyPointer <= 0;
            redoButton.disabled = historyPointer >= history.length - 1;
            console.log(`[History] Buttons updated. Undo disabled: ${undoButton.disabled}, Redo disabled: ${redoButton.disabled}`);
        }

        // --- Event Listeners for Undo/Redo Buttons ---
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);


        // --- Placeholder Save Model Function ---
        function saveModel() {
            addMessageToLog('System', 'Save functionality is a placeholder. To implement actual model saving (e.g., to GLTF/GLB), a GLTFExporter would be required, which involves more complex Three.js serialization.');
            speakResponse('Save feature is not fully implemented yet.');
            console.warn("Save Model: Placeholder function executed. Actual GLTF/GLB export not implemented.");
        }

        // --- Apply CSS Function (remains the same, but now accessed via AI command or direct console) ---
        applyCssButton.addEventListener('click', () => {
            console.log("[Apply CSS] button clicked."); // Debug log
            const cssText = cssCodeEditor.value;
            try {
                // Clear existing inline styles to prevent conflicts
                cadViewer.style.cssText = '';

                // Apply the new CSS properties
                const lines = cssText.split(';');
                lines.forEach(line => {
                    const parts = line.split(':'); // Corrected from `line = line.split(':')`
                    if (parts.length === 2) {
                        const prop = parts[0].trim();
                        const value = parts[1].trim();
                        if (prop && value) {
                            cadViewer.style[prop] = value;
                        }
                    }
                });
                addMessageToLog('System', 'CAD viewer background CSS applied successfully.');
            } catch (error) {
                    addMessageToLog('System', `Error applying CSS: ${error.message}`);
                    console.error("Error applying CSS:", error);
            }
        });


        // --- File Input and Page Navigation ---
        dropZone.addEventListener('dragover', e => {
            e.preventDefault();
            dropZone.textContent = 'Release to drop your .gltf or .glb file(s)';
            dropZone.style.borderColor = '#007bff';
            dropZone.style.display = 'flex'; // Show dropZone on dragover
            dropZone.style.pointerEvents = 'auto'; // Enable pointer events
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.textContent = 'Drag and Drop your .gltf or .glb file(s) here';
            dropZone.style.borderColor = '#a0aec0';
            dropZone.style.display = 'none'; // Hide dropZone on dragleave
            dropZone.style.pointerEvents = 'none'; // Disable pointer events
        });
        dropZone.addEventListener('drop', async e => {
            e.preventDefault();
            dropZone.textContent = 'Processing files...';
            dropZone.style.borderColor = '#a0aec0';
            loadingMsg.textContent = 'Processing dropped files...';
            loadingMsg.style.color = '#007bff';
            loadingMsg.style.display = 'block';

            // Always hide dropZone after a drop attempt, regardless of outcome
            dropZone.style.display = 'none';
            dropZone.style.pointerEvents = 'none';


            // When dropping, assume it's a new set of files for a new model
            // If already in editor, this means adding a new model. If on upload page, it's the first model.
            // Clear previous single-file context (important for correct URL resolution)
            droppedFileBlobs.clear();
            let mainModelFile = null;

            console.log("[Drop Handler] Drop event detected. Items:", e.dataTransfer.items);
            console.log("[Drop Handler] Files:", e.dataTransfer.files);

            async function readDroppedFiles(entry, path) {
                if (entry.isFile) {
                    const file = await new Promise(resolve => entry.file(resolve));
                    const fullPath = path ? `${path}/${path}/${file.name}` : file.name; // FIX: Corrected path concatenation
                    droppedFileBlobs.set(fullPath, file);
                    console.log(`[Drop Handler] Stored file: ${fullPath}, Type: ${file.type}, Size: ${file.size} bytes`);
                    if (!mainModelFile && (file.name.toLowerCase().endsWith('.gltf') || file.name.toLowerCase().endsWith('.glb'))) {
                        mainModelFile = file;
                    }
                } else if (entry.isDirectory) {
                    const directoryReader = entry.createReader();
                    const entries = await new Promise(resolve => directoryReader.readEntries(resolve));
                    console.log(`[Drop Handler] Reading directory: ${path ? `${path}/${entry.name}` : entry.name}, Entries found: ${entries.length}`);
                    for (const subEntry of entries) {
                        await readDroppedFiles(subEntry, path ? `${path}/${entry.name}` : entry.name);
                    }
                }
            }

            if (e.dataTransfer.items && e.dataTransfer.items.length > 0 && e.dataTransfer.items[0].webkitGetAsEntry) {
                console.log("[Drop Handler] Using webkitGetAsEntry for folder drop detection.");
                for (let i = 0; i < e.dataTransfer.items.length; i++) {
                    const item = e.dataTransfer.items[i];
                    const entry = item.webkitGetAsEntry();
                    if (entry) {
                        await readDroppedFiles(entry, '');
                    }
                }
            } else {
                console.log("[Drop Handler] Falling back to flat file drop (webkitGetAsEntry not available or not a folder drop).");
                for (let i = 0; i < e.dataTransfer.files.length; i++) {
                    const file = e.dataTransfer.files[i];
                    droppedFileBlobs.set(file.name, file);
                    console.log(`[Drop Handler] Stored file (flat): ${file.name}, Type: ${file.type}, Size: ${file.size} bytes`);
                    if (!mainModelFile && (file.name.toLowerCase().endsWith('.gltf') || file.name.toLowerCase().endsWith('.glb'))) {
                        mainModelFile = file;
                    }
                }
            }

            if (mainModelFile) {
                uploadedFile = mainModelFile;
                console.log("[Drop Handler] Identified main model file:", uploadedFile.name);
                if (validateFile(uploadedFile)) {
                    // If already in editor, load the model directly
                    if (editorPage.classList.contains('page-active')) {
                        loadModel(uploadedFile);
                    } else {
                        loadingMsg.textContent = `File selected: ${uploadedFile.name}. Loading editor...`;
                        loadingMsg.style.color = '#007bff';
                        loadingMsg.style.display = 'block';
                        goToEditor('uploaded');
                    }
                }
                console.log("[Drop Handler] All dropped files (keys in map):", Array.from(droppedFileBlobs.keys()));
            } else {
                loadingMsg.textContent = '❌ No .gltf or .glb file found among dropped items!';
                loadingMsg.style.color = 'red';
                setTimeout(() => { // Hide message after a delay
                    loadingMsg.style.display = 'none';
                    loadingMsg.textContent = '';
                }, 3000);
            }
            console.log("[Drop Handler] uploadedFile after change processing:", uploadedFile ? uploadedFile.name : "null");
        });

        fileInput.addEventListener('change', () => {
            console.log("[File Input] Change event detected. Files:", fileInput.files);

            // Always ensure dropZone is hidden and non-interactive when file dialog closes
            dropZone.style.display = 'none';
            dropZone.style.pointerEvents = 'none';
            loadingMsg.style.display = 'none'; // Hide any previous loading message
            loadingMsg.textContent = ''; // Clear previous message

            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                uploadedFile = file;
                console.log("[File Input] Selected file:", uploadedFile.name, `Type: ${uploadedFile.type}, Size: ${uploadedFile.size} bytes`);

                if (validateFile(uploadedFile)) {
                    loadingMsg.textContent = `Processing selected file: ${uploadedFile.name}...`;
                    loadingMsg.style.color = '#007bff';
                    loadingMsg.style.display = 'block'; // Show loading message *only* if a file is valid

                    droppedFileBlobs.clear(); // Clear previous context
                    droppedFileBlobs.set(file.name, file); // Store the selected file

                    if (editorPage.classList.contains('page-active')) {
                        loadModel(uploadedFile);
                    } else {
                        loadingMsg.textContent = `File selected: ${uploadedFile.name}. Loading editor...`;
                        loadingMsg.style.color = '#007bff';
                        loadingMsg.style.display = 'block';
                        goToEditor('uploaded');
                    }
                } else {
                    // Validation failed, message already set by validateFile
                    setTimeout(() => { // Hide message after a delay
                        loadingMsg.style.display = 'none';
                        loadingMsg.textContent = '';
                    }, 3000);
                }
            } else {
                console.log("[File Input] No file selected via input (e.g., dialog cancelled or no file chosen).");
                uploadedFile = null;
                // No need to show a message if nothing was selected, just clear any previous ones.
                // loadingMsg.textContent = 'No file selected.';
                // loadingMsg.style.color = 'orange';
                // loadingMsg.style.display = 'block';
                // setTimeout(() => {
                //     loadingMsg.style.display = 'none';
                //     loadingMsg.textContent = '';
                // }, 3000);
            }
            console.log("[File Input] uploadedFile after change processing:", uploadedFile ? uploadedFile.name : "null");
        });

        function validateFile(file) {
            console.log("[Validation] Validating file:", file ? file.name : "null");
            if (file && (file.name.toLowerCase().endsWith('.gltf') || file.name.toLowerCase().endsWith('.glb'))) {
                console.log("[Validation] File is a valid GLTF/GLB.");
                return true;
            } else {
                console.error("[Validation] Unsupported file type! Please upload a .gltf or .glb file.");
                // Set message for the caller to display/hide
                loadingMsg.textContent = '❌ Unsupported file type! Please upload a .gltf or .glb file.';
                loadingMsg.style.color = 'red';
                uploadedFile = null;
                return false;
            }
        }

        function disposeSceneResources() {
            console.log("[Dispose] Disposing Three.js resources...");
            if (scene) {
                // Remove all loaded models and dispose their resources
                loadedModels.forEach(model => {
                    scene.remove(model);
                    model.traverse(function (object) {
                        if (object.isMesh) {
                            if (object.geometry) object.geometry.dispose();
                            if (object.material) {
                                if (Array.isArray(object.material)) {
                                    object.material.forEach(mat => mat.dispose());
                                } else {
                                    object.material.dispose();
                                }
                            }
                        }
                    });
                });
                loadedModels = []; // Clear the array of loaded models

                // Remove grid helper and labels specifically if they exist
                if (currentGridHelper) {
                    scene.remove(currentGridHelper);
                    currentGridHelper.geometry.dispose();
                    currentGridHelper.material.dispose();
                    currentGridHelper = null;
                }
                currentGridLabels.forEach(label => {
                    scene.remove(label);
                    if (label.material) label.material.dispose();
                    if (label.geometry) label.geometry.dispose();
                });
                currentGridLabels = [];

                // Dispose renderer and controls only if they exist
                if (renderer) {
                    renderer.setAnimationLoop(null);
                    renderer.dispose();
                    renderer = null;
                }
                if (controls) {
                    controls.removeEventListener('change', updateDynamicGrid); // Remove listener
                    controls.dispose();
                    controls = null;
                }
                if (cadCanvas) {
                    cadCanvas.removeEventListener('mousedown', onCanvasClick, false);
                    cadCanvas.removeEventListener('touchstart', onCanvasClick, false);
                }
                if (transformControls) {
                    transformControls.dispose();
                    transformControls = null;
                }
                // Dispose view axes helper and its scene/camera/renderer only if they exist
                if (viewAxesHelper) {
                    // Iterate through children of viewAxesHelper (the axis meshes)
                    viewAxesHelper.children.forEach(child => {
                        if (child.isMesh) {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => mat.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        }
                    });
                    viewAxesScene.remove(viewAxesHelper); // Remove the group itself
                    viewAxesHelper = null;
                }
                if (viewAxesRenderer) {
                    viewAxesRenderer.setAnimationLoop(null);
                    viewAxesRenderer.dispose();
                    viewAxesRenderer = null;
                }
                if (viewAxesCamera) {
                    viewAxesCamera = null;
                }
                // Clear the container for the view axes helper
                if (viewAxesContainer) {
                    viewAxesContainer.innerHTML = '';
                }

                // Dispose debug sphere if it exists
                if (raycastDebugSphere) {
                    scene.remove(raycastDebugSphere);
                    if (raycastDebugSphere.geometry) raycastDebugSphere.geometry.dispose();
                    if (raycastDebugSphere.material) raycastDebugSphere.material.dispose();
                    raycastDebugSphere = null;
                }

                // Re-initialize scene after disposal to ensure a clean state
                initScene();
            }
            originalMaterialProperties.clear(); // Clear this map too
            allHighlightsOriginalMaterials.clear(); // Clear all highlights map
            selectedObject = null; // Clear selected object
            currentlySelectedObjectsForEditing = []; // Clear the functional selection array
            console.log("[Dispose] Resources disposed and scene re-initialized.");
        }


        function goToEditor(loadType = 'empty') { // Default to 'empty' if no type specified
            console.log(`[goToEditor] Function called with load type: ${loadType}.`); // Added log

            // Dispose and re-init scene to ensure a clean state for new or loaded models
            disposeSceneResources();

            if (loadType === 'random') {
                console.log("[goToEditor] Loading a random model.");
                loadRandomModel();
                addMessageToLog('System', 'Loading a random model. Use "Upload New File" to add more models.');
                speakResponse('Loading a random model. You can upload files from the editor.');
            } else if (loadType === 'empty') {
                console.log("[goToEditor] Creating an empty model scene.");
                addMessageToLog('System', 'Starting a new, empty model. Use "Upload New File" to load models.');
                speakResponse('Starting a new, empty model. You can upload files from the editor.');
                // No model loading needed for empty scene, just initScene() handles the grid.
            } else if (loadType === 'uploaded' && uploadedFile) {
                loadingMsg.textContent = `Loading model: ${uploadedFile.name}...`;
                loadingMsg.style.color = '#007bff';
                loadingMsg.style.display = 'block';
                console.log(`[goToEditor] Transitioning to editor. Preparing to load uploaded model: ${uploadedFile.name}`);
                console.log(`[goToEditor] Current droppedFileBlobs keys:`, Array.from(droppedFileBlobs.keys()));
                loadModel(uploadedFile);
            } else {
                console.warn("[goToEditor] Invalid loadType or no uploadedFile for 'uploaded' type. Defaulting to empty scene.");
                addMessageToLog('System', 'Invalid load request. Starting with an empty scene.');
                speakResponse('Invalid load request. Starting with an empty scene.');
            }

            uploadPage.classList.remove('page-active');
            uploadPage.classList.add('page-inactive');

            editorPage.classList.remove('page-inactive');
            editorPage.classList.add('page-active');
            console.log("[goToEditor] Page transition complete. Editor page is now active.");
        }

        function loadRandomModel() {
            // Added error handling for empty RANDOM_MODEL_URLS
            if (RANDOM_MODEL_URLS.length === 0) {
                console.warn("[loadRandomModel] RANDOM_MODEL_URLS is empty. Cannot load a random model.");
                addMessageToLog('System', 'No random models available to load. Please try uploading a model or creating a new one.');
                speakResponse('No random models available to load.');
                return;
            }

            const randomIndex = Math.floor(Math.random() * RANDOM_MODEL_URLS.length);
            const modelUrl = RANDOM_MODEL_URLS[randomIndex];
            console.log(`[loadRandomModel] Attempting to load random model from URL: ${modelUrl} (Index: ${randomIndex})`); // Added index to log
            const loader = new GLTFLoader();
            loader.load(modelUrl, (gltf) => {
                const randomModel = gltf.scene;
                randomModel.name = `Random Model (${modelUrl.split('/').pop()})`;
                scene.add(randomModel);
                // Store initial material(s) for the loaded model or its meshes
                randomModel.traverse((obj) => {
                    if (obj.isMesh && obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.userData.initialMaterial = obj.material.map(mat => mat.clone());
                        } else {
                            obj.userData.initialMaterial = obj.material.clone();
                        }
                    }
                });
                loadedModels.push(randomModel);
                resetView();
                addMessageToLog('System', `Random model "${randomModel.name}" loaded successfully.`);
                speakResponse(`Random model loaded.`);
                console.log(`[loadRandomModel] Random model "${randomModel.name}" loaded successfully.`);
                saveSceneState(); // Save state after loading a new model
            }, (xhr) => { // Progress callback
                loadingMsg.textContent = `Loading ${modelUrl}: ${Math.round(xhr.loaded / xhr.total * 100)}%`;
            }, (error) => {
                console.error(`[loadRandomModel] Error loading random model from ${modelUrl}:`, error);
                addMessageToLog('System', `Failed to load random model from ${modelUrl}. Error details in console. Please try another option.`); // More specific error message
                speakResponse(`Failed to load random model. Please check the console for details.`);
            });
        }


        function goBack() {
            console.log("[Navigation] Going back to upload page.");
            editorPage.classList.remove('page-active');
            editorPage.classList.add('page-inactive');
            uploadPage.classList.remove('page-inactive');
            uploadPage.classList.add('page-active');
            stopVoiceAssist();
            window.removeEventListener('resize', onWindowResize, false);
            disposeSceneResources(); // This will clear all models and re-initialize the scene
            uploadedFile = null;
            droppedFileBlobs.clear();
            originalMaterialProperties.clear(); // Clear this map too
            allHighlightsOriginalMaterials.clear(); // Clear all highlights map
            selectedObject = null;
            currentlySelectedObjectsForEditing = []; // Clear the functional selection array
            fileInput.value = ''; // Clear file input value
            loadingMsg.textContent = 'Drag and Drop your .gltf or .glb file(s) here, or click to browse.';
            loadingMsg.style.display = 'none';
            loadingMsg.style.color = '';
            dropZone.textContent = 'Drag and Drop your .gltf or .glb file(s) here';
            dropZone.style.borderColor = '#a0aec0';
            // Hide dropZone and loadingMsg when returning to the upload page
            dropZone.style.display = 'none';
            dropZone.style.pointerEvents = 'none';
            loadingMsg.style.display = 'none';
            console.log("[Navigation] Returned to upload page. State reset.");
            addMessageToLog('System', 'Welcome back! Choose an option to get started.');
            updateUndoRedoButtons(); // Update buttons on page change
        }

        // --- Three.js Scene Setup and Model Loading ---
        function initScene() {
            console.log("[initScene] Initializing Three.js scene...");
            if (typeof THREE === 'undefined') {
                console.error("THREE is not defined at initScene! Three.js script might not have loaded or executed correctly.");
                addMessageToLog('System', "Error: Three.js library failed to load. Please check console for details.");
                return;
            }
            // Only create new scene, renderer, camera, controls if they don't exist
            if (!scene) {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xFFFFFF); // Pure white background
            }
            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ canvas: cadCanvas, antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.xr.enabled = true;
            }
            if (!camera) {
                const viewerDiv = cadCanvas.parentElement;
                camera = new THREE.PerspectiveCamera(75, viewerDiv.clientWidth / viewerDiv.clientHeight, 0.1, 1000);
                // Adjusted initial camera position for a more "twisted" or perspective view
                camera.position.set(30, 30, 30); // Set camera at an angle
            }
            if (!controls) {
                controls = new OrbitControls(camera, renderer.domElement); // Corrected
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.addEventListener('change', updateDynamicGrid); // Call on camera change
                controls.target.set(0, 0, 0); // Ensure controls target the origin
            }
            if (!transformControls) {
                transformControls = new TransformControls(camera, renderer.domElement); // Corrected
                scene.add(transformControls);
                transformControls.addEventListener('dragging-changed', function (event) {
                    controls.enabled = !event.value;
                });
                transformControls.visible = false; // Initialize as hidden
            }

            // Ensure renderer size is correct on init/re-init
            const viewerDiv = cadCanvas.parentElement;
            renderer.setSize(viewerDiv.clientWidth, viewerDiv.clientHeight);
            camera.aspect = viewerDiv.clientWidth / viewerDiv.clientHeight;
            camera.updateProjectionMatrix();


            // Call updateDynamicGrid initially to set up the first grid
            updateDynamicGrid();

            // Increased lighting for better visibility
            // Remove existing lights before adding new ones to prevent duplicates on re-init
            scene.children.filter(c => c.isLight).forEach(light => scene.remove(light));

            const ambientLight = new THREE.AmbientLight(0x808080); // Brighter ambient light
            scene.add(ambientLight);
            // FIX: Corrected typo from DirectionionalLight to DirectionalLight
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Full intensity directional light
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.7); // Additional light from another angle
            directionalLight2.position.set(-1, -1, -1).normalize();
            scene.add(directionalLight2);


            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            // Remove previous listeners before adding new ones to prevent duplicates on re-init
            cadCanvas.removeEventListener('mousedown', onCanvasClick, false);
            cadCanvas.removeEventListener('touchstart', onCanvasClick, false);
            cadCanvas.addEventListener('mousedown', onCanvasClick, false);
            cadCanvas.addEventListener('touchstart', onCanvasClick, false);

            initViewAxesHelper(); // Initialize the static view axes helper

            // Initialize raycast debug sphere
            if (!raycastDebugSphere) {
                raycastDebugSphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 }) // Yellow sphere
                );
                raycastDebugSphere.visible = false; // Initially hidden
                scene.add(raycastDebugSphere);
            }

            console.log("[initScene] Three.js scene initialized.");
            animate();
        }

        // Function to create a text sprite
        function makeTextSprite(message, parameters) {
            if (parameters === undefined) parameters = {};
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 40;
            const borderThickness = 0; // Removed border
            const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 0.0 }; // Transparent border
            const backgroundColor = parameters.backgroundColor || { r: 255, g: 255, b: 255, a: 0.0 }; // Transparent background
            const textColor = parameters.textColor || { r: 0, g: 0, b: 0, a: 1.0 };

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = "Bold " + fontsize + "px " + fontface;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            // Adjust canvas size to fit text
            canvas.width = textWidth + borderThickness * 2;
            canvas.height = fontsize + borderThickness * 2;

            context.font = "Bold " + fontsize + "px " + fontface;
            context.textBaseline = "middle"; // Center vertically
            context.textAlign = "center";   // Center horizontally

            // background color (if not transparent)
            if (backgroundColor.a > 0) {
                context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
                context.fillRect(0, 0, canvas.width, canvas.height);
            }

            context.fillStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", " + textColor.a + ")";
            context.fillText(message, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.userData.isGridLabel = true; // Mark as grid label for easy removal
            return sprite;
        }

        function updateDynamicGrid() {
            // Defensive check: only proceed if controls is defined
            if (!controls) {
                console.warn("[updateDynamicGrid] Controls not initialized, skipping dynamic grid update.");
                return;
            }

            // Clear existing grid and labels
            if (currentGridHelper) {
                scene.remove(currentGridHelper);
                currentGridHelper.geometry.dispose();
                currentGridHelper.material.dispose();
                currentGridHelper = null;
            }
            currentGridLabels.forEach(label => {
                scene.remove(label);
                if (label.material) label.material.dispose();
                if (label.geometry) label.geometry.dispose();
            });
            currentGridLabels = [];

            // Calculate distance to the center of the orbit (controls.target is usually 0,0,0)
            const distance = camera.position.distanceTo(controls.target);

            let gridSize, divisions, labelInterval, labelFontSize, labelScaleFactor;
            let gridLineColor = 0xbbbbbb; // Light grey for grid lines
            let centerLineColor = 0x888888; // Slightly darker for center lines
            // Very light grey for "less bright" effect on pure white background
            let labelTextColor = { r: 180, g: 180, b: 180, a: 1.0 };

            // Define grid levels based on camera distance
            // Further reduced labelScaleFactor and labelFontSize for all levels
            if (distance < 5) { // Very close zoom
                gridSize = 20;
                divisions = 20; // 1 unit per division
                labelInterval = 2; // Labels every 2 units
                labelFontSize = 10; // Very small base font size
                labelScaleFactor = 0.02; // Very small scale factor
            } else if (distance < 20) { // Close zoom
                gridSize = 50;
                divisions = 25; // 2 units per division
                labelInterval = 5; // Labels every 5 units
                labelFontSize = 12; // Very small base font size
                labelScaleFactor = 0.025; // Very small scale factor
            } else if (distance < 80) { // Medium zoom
                gridSize = 100;
                divisions = 20; // 5 units per division
                labelInterval = 10; // Labels every 10 units
                labelFontSize = 14; // Small base font size
                labelScaleFactor = 0.03; // Small scale factor
            } else if (distance < 250) { // Further zoom
                gridSize = 250;
                divisions = 25; // 10 units per division
                labelInterval = 25; // Labels every 25 units
                labelFontSize = 16; // Small base font size
                labelScaleFactor = 0.035; // Small scale factor
            } else if (distance < 600) { // Even further zoom
                gridSize = 600;
                divisions = 30; // 20 units per division
                labelInterval = 50; // Labels every 50 units
                labelFontSize = 18; // Slightly larger base font size
                labelScaleFactor = 0.04; // Slightly larger scale factor
            }
            else { // Very far zoom
                gridSize = 1000;
                divisions = 25; // 40 units per division
                labelInterval = 100; // Labels every 100 units
                labelFontSize = 20; // Slightly larger base font size
                labelScaleFactor = 0.045; // Slightly larger scale factor
            }

            // Create new GridHelper
            const newGridHelper = new THREE.GridHelper(gridSize, divisions, centerLineColor, gridLineColor);
            newGridHelper.material.opacity = 0.2;
            newGridHelper.material.transparent = true;
            newGridHelper.name = 'gridHelper';
            scene.add(newGridHelper);
            currentGridHelper = newGridHelper;

            // Create new labels
            const labelOffset = 0.5; // Kept small and fixed for now
            // Only add labels if the current grid density makes sense for them
            if (labelInterval <= gridSize / 5) { // Arbitrary threshold to avoid too many labels
                for (let i = -gridSize / 2; i <= gridSize / 2; i += labelInterval) {
                    // Skip origin and potentially very small numbers if interval is large
                    if (i === 0 || (labelInterval > 10 && Math.abs(i) < labelInterval)) continue;

                    // X-axis labels
                    const xLabel = makeTextSprite(i.toString(), { textColor: labelTextColor, fontsize: labelFontSize });
                    // Position along Z-edge, adjusted by label size, and slightly offset to prevent overlap with grid lines
                    xLabel.position.set(i, labelOffset, -gridSize / 2 - (labelFontSize * labelScaleFactor * 0.75));
                    xLabel.scale.set(labelFontSize * labelScaleFactor, labelFontSize * labelScaleFactor, 1); // Scale based on font size and factor
                    scene.add(xLabel);
                    currentGridLabels.push(xLabel);

                    // Z-axis labels
                    const zLabel = makeTextSprite(i.toString(), { textColor: labelTextColor, fontsize: labelFontSize });
                    // Position along X-edge, adjusted by label size, and slightly offset
                    zLabel.position.set(-gridSize / 2 - (labelFontSize * labelScaleFactor * 0.75), labelOffset, i);
                    zLabel.scale.set(labelFontSize * labelScaleFactor, labelFontSize * labelScaleFactor, 1);
                    scene.add(zLabel);
                    currentGridLabels.push(zLabel);
                }
            }
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                controls.update();
                renderer.render(scene, camera);
                // Render the static view axes helper scene
                if (viewAxesRenderer && viewAxesScene && viewAxesCamera) {
                     viewAxesRenderer.render(viewAxesScene, viewAxesCamera);
                }
            });
        }

        function loadModel(file) {
            console.log("[loadModel] Attempting to load file:", file.name);
            const loader = new GLTFLoader();
            const fileLoader = new THREE.FileLoader();
            fileLoader.manager = new THREE.LoadingManager();
            fileLoader.manager.setURLModifier(url => {
                console.log(`[URLModifier] Requested URL: "${url}"`);
                const fileName = url.split('/').pop();
                let resolvedPath = fileName;
                if (url.startsWith('blob:')) {
                    const blobFile = Array.from(droppedFileBlobs.values()).find(f => URL.createObjectURL(f) === url);
                    if (blobFile) {
                        resolvedPath = blobFile.name;
                        console.log(`[URLModifier] Resolved blob URL to file: ${resolvedPath}`);
                    }
                } else {
                    const potentialPaths = Array.from(droppedFileBlobs.keys()).filter(key => key.endsWith(fileName));
                    if (potentialPaths.length > 0) {
                        potentialPaths.sort((a, b) => a.length - b.length)[0]; // Use the shortest path if multiple
                        resolvedPath = potentialPaths.sort((a, b) => a.length - b.length)[0];
                        console.log(`[URLModifier] Resolved relative path to: ${resolvedPath}`);
                    }
                }
                const foundFile = droppedFileBlobs.get(resolvedPath);
                if (foundFile) {
                    const blobURL = URL.createObjectURL(foundFile);
                    console.log(`[URLModifier] Returning Blob URL for ${resolvedPath}: ${blobURL}`);
                    return blobURL;
                } else {
                    console.warn(`[URLModifier] GLTFLoader could not find referenced file: "${url}" (tried "${resolvedPath}", and potentially combined paths). Falling back to original URL.`);
                    return url;
                }
            });
            const reader = new FileReader();
            reader.onload = (event) => {
                const contents = event.target.result;
                console.log(`[FileReader] ${file.name} read successfully.`);
                loader.manager = fileLoader.manager;
                loader.parse(contents, '', (gltf) => {
                    console.log("[GLTFLoader] .gltf/.glb parsing successful.");

                    const newModel = gltf.scene;
                    newModel.name = file.name; // Assign the file name to the model for identification
                    scene.add(newModel); // Add the new model to the scene

                    // Store initial material(s) for the entire model or its meshes
                    newModel.traverse((obj) => {
                        if (obj.isMesh && obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.userData.initialMaterial = obj.material.map(mat => mat.clone());
                            } else {
                                obj.userData.initialMaterial = obj.material.clone();
                            }
                        }
                    });

                    loadedModels.push(newModel); // Store the new model in our array

                    console.log(`[loadModel] Model '${file.name}' added to scene. Total models: ${loadedModels.length}`);
                    console.log("[loadModel] New model bounding box:", new THREE.Box3().setFromObject(newModel));

                    // Call resetView to adjust camera and controls to fit all loaded models
                    resetView();

                    loadingMsg.style.display = 'none';
                    addMessageToLog('System', `Model '${file.name}' loaded successfully. You now have ${loadedModels.length} models in the scene.`);
                    speakResponse(`Model loaded successfully. You now have ${loadedModels.length} models in the scene.`);
                    console.log("[loadModel] Model successfully added to scene. Current loadedModels:", loadedModels);

                    saveSceneState(); // Save state after loading a new model
                }, (xhr) => { // Progress callback
                    loadingMsg.textContent = `Loading ${file.name}: ${Math.round(xhr.loaded / xhr.total * 100)}%`;
                }, (error) => {
                    console.error('An error happened loading the GLTF model:', error);
                    addMessageToLog('System', 'Error loading model. Please ensure it\'s a valid .gltf or .glb file and all associated files (like textures) are in the same folder if dropped as a folder, or embedded within the .glb.');
                    speakResponse(`Error loading model. Please check the console for details.`);
                    loadingMsg.textContent = '❌ Error loading model!';
                    loadingMsg.style.color = 'red';
                });
            };
            reader.readAsArrayBuffer(file);
        }

        // --- Model Interaction (Selection, Transformation, Information) ---
        let mouseDownX = 0;
        let mouseDownY = 0;
        const CLICK_TOLERANCE = 15; // Increased from 10 to 15 for more forgiving click detection

        // Global highlight material (re-use this instance)
        const highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0x1e90ff, // Dodger Blue
            transparent: true,
            opacity: 0.8,
            depthTest: false, // Important: Render without considering depth
            depthWrite: false // Important: Do not write to depth buffer
        });

        function onCanvasClick(event) {
            console.log(`[onCanvasClick] Event type: ${event.type}, Button: ${event.button}`);
            // Only process left-click (mouse button 0) or touchstart
            if (event.type === 'mousedown' && event.button !== 0) {
                console.log("[onCanvasClick] Ignoring non-left click or non-touchstart event.");
                return;
            }

            // If TransformControls are currently active and dragging, do not process selection
            if (transformControls && transformControls.dragging) {
                console.log("[onCanvasClick] TransformControls are dragging, skipping selection.");
                return;
            }

            // Store initial pointer position on mousedown/touchstart
            if (event.type === 'touchstart') {
                mouseDownX = event.touches[0].clientX;
                mouseDownY = event.touches[0].clientY;
            } else {
                mouseDownX = event.clientX;
                mouseDownY = event.clientY;
            }
            console.log(`[onCanvasClick] Mouse/Touch Down: Initial(${mouseDownX}, ${mouseDownY})`);

            // Add a temporary mouseup/touchend listener to check for drag vs click
            const onPointerUp = (upEvent) => {
                let currentX, currentY;
                if (upEvent.type === 'touchend') {
                    // For touchend, use changedTouches as touches array might be empty
                    if (upEvent.changedTouches && upEvent.changedTouches.length > 0) {
                        currentX = upEvent.changedTouches[0].clientX;
                        currentY = upEvent.changedTouches[0].clientY;
                    } else {
                        // Fallback if changedTouches is also empty (unlikely but safe)
                        currentX = mouseDownX;
                        currentY = mouseDownY;
                    }
                } else {
                    currentX = upEvent.clientX;
                    currentY = upEvent.clientY;
                }

                const deltaX = Math.abs(mouseDownX - currentX);
                const deltaY = Math.abs(mouseDownY - currentY);

                console.log(`[onCanvasClick] Mouse/Touch Up: Final(${currentX}, ${currentY}). DeltaX=${deltaX}, DeltaY=${deltaY}. Tolerance=${CLICK_TOLERANCE}`);

                // Visual feedback for any click registered
                cadViewer.style.backgroundColor = '#E0F2F7'; // Light blue flash
                setTimeout(() => {
                    cadViewer.style.backgroundColor = '#FFFFFF'; // Revert to white
                }, 100);


                if (deltaX > CLICK_TOLERANCE || deltaY > CLICK_TOLERANCE) {
                    console.log("[onCanvasClick] Detected drag (movement exceeded tolerance), skipping selection.");
                } else {
                    // It was a click, proceed with raycasting
                    console.log("[onCanvasClick] Detected click (movement within tolerance), processing selection.");
                    // Normalize mouse coordinates for raycasting using the initial mousedown position
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((mouseDownX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((mouseDownY - rect.top) / rect.height) * 2 + 1;
                    console.log(`[onCanvasClick] Normalized mouse coords for raycasting: X=${mouse.x.toFixed(4)}, Y=${mouse.y.toFixed(4)}`);
                    console.log(`[onCanvasClick] Raycaster set from camera. Mouse: (${mouse.x.toFixed(3)}, ${mouse.y.toFixed(3)})`);
                    console.log(`[onCanvasClick] Camera position: (${camera.position.x.toFixed(3)}, ${camera.position.y.toFixed(3)}, ${camera.position.z.toFixed(3)})`);
                    console.log(`[onCanvasClick] Camera fov: ${camera.fov}, aspect: ${camera.aspect}`);


                    raycaster.setFromCamera(mouse, camera);

                    const objectsToIntersect = [];
                    scene.traverse((obj) => { // Traverse the entire scene
                        // Only consider meshes that are visible and not part of the grid or labels
                        if (obj.isMesh && obj.visible && !obj.userData.isGridLabel && obj !== currentGridHelper && obj !== raycastDebugSphere) { // Exclude debug sphere
                            objectsToIntersect.push(obj);
                        }
                    });
                    console.log(`[onCanvasClick] Total visible meshes considered for intersection: ${objectsToIntersect.length}`);
                    if (objectsToIntersect.length === 0) {
                        console.log("[onCanvasClick] No meshes available to intersect.");
                    }


                    const intersects = raycaster.intersectObjects(objectsToIntersect, true);
                    console.log(`[onCanvasClick] Intersections found by raycaster: ${intersects.length}`);


                    if (intersects.length > 0) {
                        const intersectedObject = intersects[0].object;
                        console.log("[onCanvasClick] Object intersected:", intersectedObject.name || "Unnamed Object", "UUID:", intersectedObject.uuid, "Type:", intersectedObject.type, "Parent:", intersectedObject.parent ? intersectedObject.parent.name || intersectedObject.parent.uuid : 'none');

                        // Show raycast debug sphere
                        raycastDebugSphere.position.copy(intersects[0].point); // Position at intersection point
                        raycastDebugSphere.visible = true;
                        setTimeout(() => {
                            raycastDebugSphere.visible = false; // Hide after a short delay
                        }, 500);

                        selectObject(intersectedObject);
                    } else {
                        console.log("[onCanvasClick] No object intersected by raycaster. Clearing selection.");
                        // Hide debug sphere if no intersection
                        raycastDebugSphere.visible = false;
                        clearSelection();
                    }
                }

                // Clean up the temporary listeners
                renderer.domElement.removeEventListener('mouseup', onPointerUp);
                    renderer.domElement.removeEventListener('touchend', onPointerUp);
            };

            // Attach temporary listeners for mouseup/touchend
            renderer.domElement.addEventListener('mouseup', onPointerUp, { once: true });
            renderer.domElement.addEventListener('touchend', onPointerUp, { once: true });
        }

        function selectObject(object) {
            console.log(`[selectObject] Function called with object: ${object ? object.name || object.uuid : 'null'}`);
            console.log(`[selectObject] Current selectedObject BEFORE: ${selectedObject ? selectedObject.name || selectedObject.uuid : 'null'}`);

            // Clear any existing "select all" highlights first if this object was part of it
            if (allHighlightsOriginalMaterials.size > 0) {
                // Clear all highlights and the currentlySelectedObjectsForEditing array
                clearAllHighlights();
            }

            // Clear any previous individual selection
            clearSelection();

            if (object) {
                selectedObject = object;
                console.log(`[selectObject] Selected object set to: ${selectedObject.name || 'Unnamed Object'} (UUID: ${selectedObject.uuid})`);

                const materials = Array.isArray(selectedObject.material) ? selectedObject.material : [selectedObject.material];
                const objectOriginalMaterials = []; // Array to store original material instances

                materials.forEach((mat, index) => {
                    if (mat && mat.isMaterial) { // Defensive check for valid material
                        console.log(`[selectObject] Processing material ${index}: Type=${mat.type}, Color=${mat.color ? mat.color.getHexString() : 'N/A'}, Emissive=${mat.emissive ? mat.emissive.getHexString() : 'N/A'}`);

                        // Store the original material instance itself
                        objectOriginalMaterials.push(mat.clone()); // Store a clone of the current material for highlight reversion

                        // Apply highlight
                        if (mat.emissive !== undefined) {
                            mat.emissive.copy(highlightMaterial.color);
                            mat.emissiveIntensity = 0.5; // Adjust intensity as needed
                            console.log(`[selectObject] Applied emissive highlight to material for ${selectedObject.name || 'Unnamed Object'} (material index ${index}).`);
                        } else if (mat.color !== undefined) {
                            // If no emissive, change the main color
                            mat.color.copy(highlightMaterial.color);
                            console.log(`[selectObject] Applied color highlight to material for ${selectedObject.name || 'Unnamed Object'} (material index ${index}).`);
                        } else {
                            console.warn(`[selectObject] Material for ${object.name || 'Unnamed Part'} (UUID: ${object.uuid}, material index ${index}) does not have an emissive or color property. Highlighting might not work as expected.`);
                        }
                        mat.needsUpdate = true;
                    } else {
                        console.warn(`[selectObject] Material at index ${index} for object ${object.name || object.uuid} is null or not a valid material. Skipping highlight.`);
                    }
                });
                originalMaterialProperties.set(selectedObject.uuid, objectOriginalMaterials); // Store the array of current materials for individual selection reversion

                transformControls.attach(selectedObject);
                transformControls.visible = true; // Make controls visible
                console.log(`[selectObject] TransformControls attached: ${transformControls.object ? transformControls.object.name || transformControls.object.uuid : 'none'}`);
                console.log(`[selectObject] TransformControls visible: ${transformControls.visible}`);
                addMessageToLog('System', `Selected: ${object.name || 'Unnamed Part'} (UUID: ${object.uuid})`);
                speakResponse(`Selected ${object.name || 'a part'}.`);
            } else {
                console.log("[selectObject] No object provided for selection, clearing any existing selection.");
                clearSelection(); // If no object is passed, clear selection
            }
            console.log(`[selectObject] Current selectedObject AFTER: ${selectedObject ? selectedObject.name || selectedObject.uuid : 'null'}`);
        }

        function clearSelection() {
            console.log(`[clearSelection] Function called. selectedObject BEFORE: ${selectedObject ? selectedObject.name || selectedObject.uuid : 'null'}`);
            if (selectedObject && originalMaterialProperties.has(selectedObject.uuid)) {
                console.log(`[clearSelection] Reverting highlight for: ${selectedObject.name || 'Unnamed Part'} (UUID: ${selectedObject.uuid})`);

                const originalMaterials = originalMaterialProperties.get(selectedObject.uuid); // Get the array of original material instances
                const currentMaterials = Array.isArray(selectedObject.material) ? selectedObject.material : [selectedObject.material];

                currentMaterials.forEach((mat, index) => {
                    if (mat && mat.isMaterial && originalMaterials[index]) { // Defensive check
                        mat.dispose(); // Dispose current material before replacing to avoid memory leaks
                        // Assign the original material instance back
                        // Use the initialMaterial if available, otherwise fallback to the one stored for temporary highlight
                        if (selectedObject.userData.initialMaterial && (Array.isArray(selectedObject.userData.initialMaterial) ? selectedObject.userData.initialMaterial[index] : selectedObject.userData.initialMaterial)) {
                            if (Array.isArray(selectedObject.material)) {
                                selectedObject.material[index] = selectedObject.userData.initialMaterial[index].clone(); // Clone to ensure independence
                            } else {
                                selectedObject.material = selectedObject.userData.initialMaterial.clone(); // Clone to ensure independence
                            }
                        } else {
                            if (Array.isArray(selectedObject.material)) {
                                selectedObject.material[index] = originalMaterials[index];
                            } else {
                                selectedObject.material = originalMaterials[index];
                            }
                        }
                        selectedObject.material.needsUpdate = true;
                        console.log(`[clearSelection] Restored material for index ${index}.`);
                    } else {
                        console.warn(`[clearSelection] Material at index ${index} for object ${selectedObject.name || selectedObject.uuid} is null or not a valid material, or no original material instance found. Skipping restore.`);
                    }
                });

                // Detach transform controls before clearing selectedObject
                if (transformControls) {
                    transformControls.detach(); // Detach controls when selection is cleared
                    transformControls.visible = false; // Explicitly hide controls
                    console.log("[clearSelection] TransformControls detached and hidden.");
                }

                originalMaterialProperties.delete(selectedObject.uuid); // Remove from map
                selectedObject = null; // Clear selected object reference
                console.log("[clearSelection] Individual selection cleared and highlight reverted.");
            } else {
                console.log("[clearSelection] No object selected or no original material properties to restore.");
            }
            currentlySelectedObjectsForEditing = []; // Clear the functional selection array
            console.log(`[clearSelection] Function finished. selectedObject AFTER: ${selectedObject ? selectedObject.name || selectedObject.uuid : 'null'}`);
            // Do NOT add message to log or speak here, as it's often called internally before a new selection.
            // addMessageToLog('System', 'Selection cleared.');
            // speakResponse('Selection cleared.');
        }

        function highlightAllModels() {
            console.log("[highlightAllModels] Attempting to highlight all models.");
            clearSelection(); // Clear any individual selection first
            clearAllHighlights(); // Clear any previous "select all" highlights

            let highlightedCount = 0;
            // Clear currentlySelectedObjectsForEditing before populating
            currentlySelectedObjectsForEditing = []; // Ensure it's empty before new selection

            // Iterate over loadedModels (top-level objects) for highlighting
            loadedModels.forEach(model => {
                model.traverse((obj) => {
                    if (obj.isMesh && obj.visible && !obj.userData.isGridLabel && obj !== currentGridHelper && obj !== raycastDebugSphere) {
                        const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                        const objectOriginalMaterials = [];

                        materials.forEach(mat => {
                            if (mat && mat.isMaterial) {
                                objectOriginalMaterials.push(mat.clone()); // Store a clone of the current material for highlight reversion
                                if (mat.emissive !== undefined) {
                                    mat.emissive.copy(highlightMaterial.color);
                                    mat.emissiveIntensity = 0.5;
                                } else if (mat.color !== undefined) {
                                    mat.color.copy(highlightMaterial.color);
                                }
                                mat.needsUpdate = true;
                                highlightedCount++;
                            }
                        });
                        allHighlightsOriginalMaterials.set(obj.uuid, objectOriginalMaterials); // Store for all-highlight reversion
                        currentlySelectedObjectsForEditing.push(obj); // Add individual mesh to functional selection array
                    }
                });
            });


            if (highlightedCount > 0) {
                addMessageToLog('AI', `Highlighted ${highlightedCount} objects in the scene.`);
                speakResponse(`Highlighted all ${highlightedCount} objects.`);
                console.log(`[highlightAllModels] Successfully highlighted ${highlightedCount} objects. Currently selected for editing (functional): ${currentlySelectedObjectsForEditing.length} objects.`);
            } else {
                addMessageToLog('System', 'No objects found to highlight in the scene.');
                speakResponse('No objects found to highlight.');
                console.log("[highlightAllModels] No objects found to highlight.");
            }
        }

        function clearAllHighlights() {
            console.log("[clearAllHighlights] Attempting to clear all highlights.");
            if (allHighlightsOriginalMaterials.size === 0) {
                console.log("[clearAllHighlights] No global highlights to clear.");
                return;
            }

            let clearedCount = 0;
            for (const [uuid, originalMaterials] of allHighlightsOriginalMaterials.entries()) {
                const object = scene.getObjectByProperty('uuid', uuid);
                if (object && object.isMesh) {
                    const currentMaterials = Array.isArray(object.material) ? object.material : [object.material];
                    currentMaterials.forEach((mat, index) => {
                        if (mat && mat.isMaterial && originalMaterials[index]) {
                            mat.dispose(); // Dispose current material before replacing
                            // Use the initialMaterial if available, otherwise fallback to the one stored for temporary highlight
                            if (object.userData.initialMaterial && (Array.isArray(object.userData.initialMaterial) ? object.userData.initialMaterial[index] : object.userData.initialMaterial)) {
                                if (Array.isArray(object.material)) {
                                    object.material[index] = object.userData.initialMaterial[index].clone(); // Clone to ensure independence
                                } else {
                                    object.material = object.userData.initialMaterial.clone(); // Clone to ensure independence
                                }
                            } else {
                                if (Array.isArray(object.material)) {
                                    object.material[index] = originalMaterials[index];
                                } else {
                                    object.material = originalMaterials[index];
                                }
                            }
                            object.material.needsUpdate = true;
                        }
                    });
                    clearedCount++;
                }
            }
            allHighlightsOriginalMaterials.clear(); // Clear the map
            currentlySelectedObjectsForEditing = []; // Clear the functional selection array
            addMessageToLog('System', `Cleared highlights from ${clearedCount} objects.`);
            speakResponse('All highlights cleared.');
            console.log(`[clearAllHighlights] Successfully cleared highlights from ${clearedCount} objects.`);
        }


        function removeObject() {
            saveSceneState(); // Save state before removing
            if (selectedObject) {
                const objectToRemoveName = selectedObject.name || "Unnamed Part";
                const objectToRemoveUUID = selectedObject.uuid;

                transformControls.detach();

                let parent = selectedObject.parent;
                if (parent) {
                    parent.remove(selectedObject);
                    if (selectedObject.geometry) selectedObject.geometry.dispose();
                    if (selectedObject.material) {
                        if (Array.isArray(selectedObject.material)) {
                            selectedObject.material.forEach(material => material.dispose());
                        } else {
                            selectedObject.material.dispose();
                        }
                    }

                    const index = loadedModels.indexOf(selectedObject);
                    if (index > -1) {
                        loadedModels.splice(index, 1);
                        console.log(`[Remove Object] Removed top-level model: ${objectToRemoveName}. Remaining models: ${loadedModels.length}`);
                    } else {
                        console.log(`[Remove Object] Removed object: ${objectToRemoveName} (UUID: ${objectToRemoveUUID})`);
                    }

                    if (originalMaterialProperties.has(selectedObject.uuid)) {
                        originalMaterialProperties.delete(selectedObject.uuid);
                    }
                    if (allHighlightsOriginalMaterials.has(selectedObject.uuid)) {
                        allHighlightsOriginalMaterials.delete(selectedObject.uuid);
                    }

                    addMessageToLog('AI', `Removed ${objectToRemoveName}.`);
                    speakResponse(`Removed ${objectToRemoveName}.`);
                    selectedObject = null;
                    currentlySelectedObjectsForEditing = [];
                    resetView();
                } else {
                    console.warn(`[Remove Object] Selected object ${objectToRemoveName} has no parent to remove from.`);
                    addMessageToLog('System', `Cannot remove ${objectToRemoveName}: No parent found.`);
                    speakResponse(`Cannot remove that part.`);
                }
            } else {
                addMessageToLog('System', 'No object selected to remove.');
                speakResponse('No object selected to remove.');
            }
            updateUndoRedoButtons();
        }

        function duplicateSelectedObject() {
            saveSceneState(); // Save state before duplicating
            console.log("[duplicateSelectedObject] Attempting to duplicate selectedObject:", selectedObject ? selectedObject.name || selectedObject.uuid : 'null');

            if (!selectedObject) {
                addMessageToLog('System', 'No object selected to duplicate.');
                speakResponse('No object selected to duplicate.');
                return;
            }

            const objectToDuplicate = selectedObject;
            const clonedObject = objectToDuplicate.clone();

            const originalMaterialsForObject = originalMaterialProperties.get(objectToDuplicate.uuid);

            if (Array.isArray(clonedObject.material)) {
                clonedObject.material = clonedObject.material.map((mat, index) => {
                    const newMat = mat.clone();
                    if (originalMaterialsForObject && originalMaterialsForObject[index]) {
                        const originalMat = originalMaterialsForObject[index];
                        newMat.copy(originalMat);
                    } else {
                        newMat.color.set(0xcccccc);
                        newMat.emissive.set(0x000000);
                        newMat.emissiveIntensity = 0;
                    }
                    newMat.needsUpdate = true;
                    return newMat;
                });
            } else if (clonedObject.material) {
                const newMat = clonedObject.material.clone();
                if (originalMaterialsForObject && originalMaterialsForObject[0]) {
                    const originalMat = originalMaterialsForObject[0];
                    newMat.copy(originalMat);
                } else {
                    newMat.color.set(0xcccccc);
                    newMat.emissive.set(0x000000);
                    newMat.emissiveIntensity = 0;
                }
                newMat.needsUpdate = true;
                clonedObject.material = newMat;
            }

            // Also set initialMaterial for the cloned object
            if (Array.isArray(clonedObject.material)) {
                clonedObject.userData.initialMaterial = clonedObject.material.map(mat => mat.clone());
            } else if (clonedObject.material) {
                clonedObject.userData.initialMaterial = clonedObject.material.clone();
            }

            const originalWorldPosition = new THREE.Vector3();
            objectToDuplicate.getWorldPosition(originalWorldPosition);
            const originalWorldQuaternion = new THREE.Quaternion();
            objectToDuplicate.getWorldQuaternion(originalWorldQuaternion);
            const originalWorldScale = new THREE.Vector3();
            objectToDuplicate.getWorldScale(originalWorldScale);

            clonedObject.position.copy(originalWorldPosition);
            clonedObject.quaternion.copy(originalWorldQuaternion);
            clonedObject.scale.copy(originalWorldScale);

            const offset = new THREE.Vector3(2, 0, 0);
            clonedObject.position.add(offset);

            clonedObject.name = `${objectToDuplicate.name || 'Unnamed Object'} (Copy)`;

            scene.add(clonedObject);
            loadedModels.push(clonedObject);

            clearSelection();
            console.log("[duplicateSelectedObject] After clearSelection(), selectedObject is now:", selectedObject);

            clearAllHighlights();
            console.log("[duplicateSelectedObject] After clearAllHighlights(), allHighlightsOriginalMaterials size is:", allHighlightsOriginalMaterials.size);

            requestAnimationFrame(() => {
                renderer.render(scene, camera);
            });

            resetView();
            addMessageToLog('AI', `Duplicated ${clonedObject.name}. No object is currently selected.`);
            speakResponse(`Duplicated the selected object.`);
            console.log("[duplicateSelectedObject] Object duplicated. No object is currently selected.");
            updateUndoRedoButtons();
        }


        function resetView() {
            saveSceneState(); // Save state before resetting view
            if (controls && camera && loadedModels.length > 0) {
                const overallBbox = new THREE.Box3();
                loadedModels.forEach(model => {
                    overallBbox.union(new THREE.Box3().setFromObject(model));
                });

                if (overallBbox.isEmpty()) {
                    console.warn("[resetView] Overall bounding box is empty. Cannot reset view.");
                    addMessageToLog('System', 'No visible models to reset view to.');
                    speakResponse('No visible models to reset view to.');
                    return;
                }

                const center = overallBbox.getCenter(new THREE.Vector3());
                const size = overallBbox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                console.log("[resetView] Overall Bounding Box:", overallBbox);
                console.log("[resetView] Center:", center);
                console.log("[resetView] Resetting view to fit all models.");
                console.log("[resetView] Size:", size);
                console.log("[resetView] Max Dimension:", maxDim);

                const fov = camera.fov * (Math.PI / 180);
                const cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

                const newCameraPosition = center.clone().add(new THREE.Vector3(maxDim * 0.8, maxDim * 0.8, maxDim * 0.8));
                camera.position.copy(newCameraPosition);
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();

                addMessageToLog('AI', 'View reset to fit all models.');
                speakResponse('View reset to fit all models.');
            } else if (controls && camera) {
                camera.position.set(30, 30, 30);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
                addMessageToLog('System', 'No models loaded. Resetting to default view.');
                speakResponse('No models loaded. Resetting to default view.');
            } else {
                addMessageToLog('System', 'Three.js components not initialized for view reset.');
                speakResponse('Cannot reset view, editor components not ready.');
            }
            updateUndoRedoButtons();
        }

        function showDesignInfo() {
            if (loadedModels.length > 0) {
                let info = `Total Models Loaded: ${loadedModels.length}\n`;
                loadedModels.forEach((model, index) => {
                    info += `\nModel ${index + 1} (${model.name || 'Unnamed Model'}):\n`;
                    info += `  Number of Meshes: ${model.children.filter(c => c.isMesh).length}\n`;
                    info += `  Total Objects: ${model.children.length}\n`;
                });

                const sceneBbox = new THREE.Box3().setFromObject(scene);
                const sceneSize = sceneBbox.getSize(new THREE.Vector3());
                info += `\nOverall Scene Bounding Box Size: X=${sceneSize.x.toFixed(2)}, Y=${sceneSize.y.toFixed(2)}, Z=${sceneSize.z.toFixed(2)}\n`;

                addMessageToLog('AI', info);
                speakResponse('Design information displayed for all loaded models.');
            } else {
                addMessageToLog('System', 'No models loaded to show design information.');
                speakResponse('No models loaded.');
            }
        }

        function setTransformMode(mode) {
            if (transformControls) {
                transformControls.setMode(mode);
                addMessageToLog('AI', `Transform mode set to ${mode}.`);
                speakResponse(`Transform mode set to ${mode}.`);
            } else {
                addMessageToLog('System', 'Transform controls not available.');
                speakResponse('Transform controls are not available.');
            }
        }

        function listParts() {
            if (loadedModels.length > 0) {
                let parts = "Parts in loaded models:\n";
                loadedModels.forEach((model, modelIndex) => {
                    parts += `\n--- Model ${modelIndex + 1} (${model.name || 'Unnamed Model'}) ---\n`;
                    let modelHasParts = false;
                    model.traverse(obj => {
                        if (obj.isMesh && obj.name) {
                            parts += `- ${obj.name}\n`;
                            modelHasParts = true;
                        }
                    });
                    if (!modelHasParts) {
                        parts += "No named parts found in this model.\n";
                    }
                });
                addMessageToLog('AI', parts);
                speakResponse('Listed parts in the models.');
            } else {
                addMessageToLog('System', 'No models loaded or no parts to list.');
                speakResponse('No models loaded or no parts to list.');
            }
        }

        function selectPartByName(partName) {
            if (loadedModels.length > 0) {
                let foundObject = null;
                for (const model of loadedModels) {
                    model.traverse((obj) => {
                        if (obj.isMesh && obj.name === partName) {
                            foundObject = obj;
                        }
                    });
                    if (foundObject) break; // Stop searching once found
                }

                if (foundObject) {
                    selectObject(foundObject);
                } else {
                    addMessageToLog('System', `Part "${partName}" not found in any loaded models.`);
                    speakResponse(`Part ${partName} not found.`);
                }
            } else {
                addMessageToLog('System', 'No models loaded to select parts from.');
                speakResponse('No models loaded.');
            }
        }

        // --- Camera View Functions (now including negative axes) ---
        function setCameraView(position, target) {
            if (camera && controls) {
                camera.position.copy(position);
                controls.target.copy(target);
                controls.update(); // Update controls after changing camera position/target
                addMessageToLog('System', `Camera view set to [${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}] looking at [${target.x.toFixed(2)}, ${target.y.toFixed(2)}, ${target.z.toFixed(2)}].`);
            } else {
                addMessageToLog('System', 'Three.js components not initialized for view change.');
            }
        }

        function getSceneCenterAndDistance() {
            const bbox = new THREE.Box3().setFromObject(scene);
            const center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const cameraDistance = maxDim * 1.5; // Adjust as needed for comfortable viewing
            return { center, cameraDistance };
        }

        function setTopView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x, center.y + cameraDistance, center.z), center);
            speakResponse('Switched to top view.');
        }

        function setBottomView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x, center.y - cameraDistance, center.z), center);
            speakResponse('Switched to bottom view.');
        }

        function setFrontView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x, center.y, center.z + cameraDistance), center);
            speakResponse('Switched to front view.');
        }

        function setBackView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x, center.y, center.z - cameraDistance), center);
            speakResponse('Switched to back view.');
        }

        function setRightView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x + cameraDistance, center.y, center.z), center);
            speakResponse('Switched to right view.');
        }

        function setLeftView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x - cameraDistance, center.y, center.z), center);
            speakResponse('Switched to left view.');
        }

        function setIsometricView() {
            // This will be similar to resetView, but explicitly for isometric
            // If models are loaded, it will fit them, otherwise a default isometric
            resetView(); // resetView already provides an isometric-like fit or default
            speakResponse('Switched to isometric view.');
        }

        // --- Static View Axes Helper ---
        let viewAxesRaycaster;
        let viewAxesMouse;
        // viewAxesSceneRendered is a global flag, already declared at the top

        function initViewAxesHelper() {
            if (viewAxesSceneRendered) return; // Prevent re-initialization

            viewAxesScene = new THREE.Scene();
            viewAxesCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 10); // Small FOV, aspect 1:1 for container
            viewAxesCamera.position.set(1.5, 1.5, 1.5); // Fixed position for isometric view of axes
            viewAxesCamera.lookAt(0, 0, 0);

            viewAxesRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha true for transparent background
            viewAxesRenderer.setPixelRatio(window.devicePixelRatio);
            viewAxesRenderer.setSize(viewAxesContainer.clientWidth, viewAxesContainer.clientHeight);
            viewAxesRenderer.domElement.style.width = '100%';
            viewAxesRenderer.domElement.style.height = '100%';
            viewAxesContainer.appendChild(viewAxesRenderer.domElement);

            // Create a custom AxesHelper with clickable parts
            viewAxesHelper = new THREE.Group();
            const axisLength = 1.0;
            const axisRadius = 0.08; // Made axes thicker for easier clicking

            // X-axis (Red)
            const xAxisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const xAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), xAxisMaterial);
            xAxisCylinder.rotation.z = -Math.PI / 2;
            xAxisCylinder.position.x = axisLength / 2;
            xAxisCylinder.userData.axis = 'x';
            xAxisCylinder.userData.direction = 'positive';
            viewAxesHelper.add(xAxisCylinder);

            const negXAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), xAxisMaterial);
            negXAxisCylinder.rotation.z = Math.PI / 2;
            negXAxisCylinder.position.x = -axisLength / 2;
            negXAxisCylinder.userData.axis = 'x';
            negXAxisCylinder.userData.direction = 'negative';
            viewAxesHelper.add(negXAxisCylinder);

            // Y-axis (Green)
            const yAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const yAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), yAxisMaterial);
            yAxisCylinder.position.y = axisLength / 2;
            yAxisCylinder.userData.axis = 'y';
            yAxisCylinder.userData.direction = 'positive';
            viewAxesHelper.add(yAxisCylinder);

            const negYAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), yAxisMaterial);
            negYAxisCylinder.rotation.z = Math.PI; // Rotate to point downwards
            negYAxisCylinder.position.y = -axisLength / 2;
            negYAxisCylinder.userData.axis = 'y';
            negYAxisCylinder.userData.direction = 'negative';
            viewAxesHelper.add(negYAxisCylinder);

            // Z-axis (Blue)
            const zAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const zAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), zAxisMaterial);
            zAxisCylinder.rotation.x = Math.PI / 2;
            zAxisCylinder.position.z = axisLength / 2;
            zAxisCylinder.userData.axis = 'z';
            zAxisCylinder.userData.direction = 'positive';
            viewAxesHelper.add(zAxisCylinder);

            const negZAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), zAxisMaterial);
            negZAxisCylinder.rotation.x = -Math.PI / 2;
            negZAxisCylinder.position.z = -axisLength / 2;
            negZAxisCylinder.userData.axis = 'z';
            negZAxisCylinder.userData.direction = 'negative';
            viewAxesHelper.add(negZAxisCylinder);

            viewAxesScene.add(viewAxesHelper);

            // Add labels (X, Y, Z)
            const labelScale = 0.2; // Adjust label size
            const labelOffset = 0.7; // Offset from axis end

            const xLabel = makeTextSprite('X', { textColor: { r: 255, g: 0, b: 0, a: 1.0 }, fontsize: 60 });
            xLabel.position.set(axisLength + labelOffset, 0, 0);
            xLabel.scale.set(labelScale, labelScale, 1);
            viewAxesScene.add(xLabel);

            const yLabel = makeTextSprite('Y', { textColor: { r: 0, g: 255, b: 0, a: 1.0 }, fontsize: 60 });
            yLabel.position.set(0, axisLength + labelOffset, 0);
            yLabel.scale.set(labelScale, labelScale, 1);
            viewAxesScene.add(yLabel);

            const zLabel = makeTextSprite('Z', { textColor: { r: 0, g: 0, b: 255, a: 1.0 }, fontsize: 60 });
            zLabel.position.set(0, 0, axisLength + labelOffset);
            zLabel.scale.set(labelScale, labelScale, 1);
            viewAxesScene.add(zLabel);


            viewAxesRaycaster = new THREE.Raycaster();
            viewAxesMouse = new THREE.Vector2();

            viewAxesContainer.addEventListener('click', onViewAxesClick, false);

            viewAxesSceneRendered = true;
        }

        function onViewAxesClick(event) {
            event.preventDefault(); // Prevent default browser behavior

            // Calculate mouse position in normalized device coordinates (NDC)
            // (-1 to +1) for both X and Y
            const rect = viewAxesRenderer.domElement.getBoundingClientRect();
            viewAxesMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            viewAxesMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            viewAxesRaycaster.setFromCamera(viewAxesMouse, viewAxesCamera);

            // Check for intersections with the individual axis meshes
            const intersects = viewAxesRaycaster.intersectObjects(viewAxesHelper.children, true);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                const axis = intersectedObject.userData.axis;
                const direction = intersectedObject.userData.direction;

                console.log(`[ViewAxesClick] Clicked on ${direction} ${axis}-axis.`);
                addMessageToLog('System', `View axis clicked: ${direction} ${axis}-axis.`);

                // Temporary visual feedback on the container
                viewAxesContainer.style.backgroundColor = '#DAA520'; // Accent yellow
                setTimeout(() => {
                    viewAxesContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.3)'; // Revert to original gray
                }, 200); // Flash for 200ms

                // Map to corresponding view functions
                if (axis === 'x') {
                    if (direction === 'positive') setRightView();
                    else setLeftView();
                } else if (axis === 'y') {
                    if (direction === 'positive') setTopView();
                    else setBottomView();
                } else if (axis === 'z') {
                    if (direction === 'positive') setFrontView();
                    else setBackView();
                }
            } else {
                console.log("[ViewAxesClick] No axis clicked. Falling back to Isometric view.");
                addMessageToLog('System', 'View axes helper clicked, but no specific axis. Resetting to Isometric view.');
                setIsometricView(); // If clicked anywhere on the helper but not an axis, go isometric
            }
        }


        // --- AI Chat and Voice Commands ---
        function addMessageToLog(sender, message) {
            const messageElement = document.createElement('p');
            messageElement.classList.add(sender === 'User' ? 'user-message' : sender === 'AI' ? 'ai-response' : 'system-message');
            messageElement.textContent = `${sender}: ${message}`;
            aiLog.appendChild(messageElement);
            aiLog.scrollTop = aiLog.scrollHeight; // Auto-scroll to bottom
        }

        // --- Backend API Configuration ---
        // This URL should point to your Render backend's AI proxy endpoint.
        const BACKEND_API_URL = "https://mingyu.onrender.com/api/ai"; // YOUR RENDER BACKEND URL HERE

        async function sendAICommand(command) {
            sendTextCommandBtn.disabled = true;
            textCommandInput.disabled = true;
            addMessageToLog('System', 'AI is thinking...');
            console.log("[sendAICommand] Sending command to Render backend:", command);

            let selectedObjectInfo = "none";
            // Check if there are objects in currentlySelectedObjectsForEditing (meaning "select all" is active)
            if (currentlySelectedObjectsForEditing.length > 0) {
                const uuids = currentlySelectedObjectsForEditing.map(obj => obj.uuid);
                selectedObjectInfo = `Multiple CAD objects are currently selected for editing with UUIDs: ${uuids.join(', ')}.`;
            } else if (selectedObject) {
                selectedObjectInfo = `A CAD object is currently selected with UUID: ${selectedObject.uuid} and name: "${selectedObject.name || 'Unnamed Part'}".`;
            } else {
                selectedObjectInfo = "No CAD object is currently selected.";
            }

            const payload = {
                prompt: `You are an AI assistant for a CAD editor. Your primary goal is to interpret user commands and return a JSON object with an "action" and "value" property.
                **VERY IMPORTANT:** Always respond with a single JSON object. Do not include any other text outside the JSON.

                Available actions and their expected JSON format:

                1.  **To duplicate the currently selected object:**
                    User input example: "duplicate it", "make a copy", "duplicate this"
                    Return:
                    \`\`\`json
                    {"action": "duplicateObject"}
                    \`\`\`

                2.  **To create a new shape:**
                    User input example: "create a box", "add a sphere", "make a cylinder"
                    Return:
                    \`\`\`json
                    {"action": "createShape", "value": "[shape_type]"}
                    \`\`\`
                    [shape_type] can be "box", "sphere", "cylinder", "cone", "pyramid", "plane", or "torus".

                3.  **To remove the selected object:**
                    User input example: "remove it", "delete this", "erase the selected object"
                    Return:
                    \`\`\`json
                    {"action": "removeObject"}
                    \`\`\`

                4.  **To reset the camera view to fit all models:**
                    User input example: "reset view", "fit all", "zoom out to see everything"
                    Return:
                    \`\`\`json
                    {"action": "resetView"}
                    \`\`\`

                5.  **To show design information (e.g., number of models, bounding box):**
                    User input example: "show design info", "what's in the scene?", "tell me about the design"
                    Return:
                    \`\`\`json
                    {"action": "showDesignInfo"}
                    \`\`\`

                6.  **To change the transform mode of the selected object:**
                    User input example: "set to translate mode", "rotate this", "switch to scale"
                    Return:
                    \`\`\`json
                    {"action": "setTransformMode", "value": "[mode]"}
                    \`\`\`
                    [mode] can be "translate", "rotate", or "scale".

                7.  **To list all named parts in the models:**
                    User input example: "list parts", "what are the parts?", "show me the parts"
                    Return:
                    \`\`\`json
                    {"action": "listParts"}
                    \`\`\`

                8.  **To select a part by its name:**
                    User input example: "select the wheel", "select part A", "choose the main body"
                    Return:
                    \`\`\`json
                    {"action": "selectPart", "value": "[part_name]"}
                    \`\`\`

                9.  **To highlight all objects in the scene:**
                    User input example: "select all", "highlight everything"
                    Return:
                    \`\`\`json
                    {"action": "selectAll"}
                    \`\`\`

                10. **To clear all highlights:**
                    User input example: "clear highlights", "unhighlight all"
                    Return:
                    \`\`\`json
                    {"action": "clearAllHighlights"}
                    \`\`\`

                11. **To rotate the selected object:**
                    User input example: "rotate 90 degrees around x", "turn it on y axis by 45"
                    Return:
                    \`\`\`json
                    {"action": "rotateAxis", "value": {"axis": "[x/y/z]", "degrees": [number]}}
                    \`\`\`
                    If axis is not specified, default to 'y'. If degrees is not specified, default to 90.

                12. **To scale the selected object:**
                    User input example: "scale it by 2", "make it half size", "scale up by 1.5"
                    Return:
                    \`\`\`json
                    {"action": "scale", "value": [factor]}
                    \`\`\`

                13. **To translate (move) the selected object:**
                    User input example: "move it 1 unit on x", "shift by -0.5 on y", "translate 2, 0, -1"
                    Return:
                    \`\`\`json
                    {"action": "translate", "value": {"x": [number], "y": [number], "z": [number]}}
                    \`\`\`
                    If a coordinate is not specified, assume 0.

                14. **To change the color of the selected object:**
                    User input example: "make it red", "change color to #00FF00", "set color to blue"
                    Return:
                    \`\`\`json
                    {"action": "changeColor", "value": "[color_value]"}
                    \`\`\`
                    [color_value] can be a color name (e.g., "red") or a hex code (e.g., "#FF0000").

                15. **For conversational responses or if the command is not understood:**
                    Return:
                    \`\`\`json
                    {"action": "conversational", "value": "[your response]"}
                    \`\`\`

                User command: "${command}".
                Current context: ${selectedObjectInfo}
                Please return *only* the JSON object for the most appropriate action based on the user's command and the current context.
                `
            };

            try {
                console.log("[sendAICommand] Fetching from backend API:", BACKEND_API_URL, "with payload:", payload);
                const response = await fetch(BACKEND_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                        // No Authorization header here, as the backend handles the OpenAI API key
                    },
                    body: JSON.stringify(payload)
                });

                console.log("[sendAICommand] Backend API response received. Status:", response.status, "OK:", response.ok);

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("[sendAICommand] Backend API Response not OK. Status:", response.status, "Status Text:", response.statusText, "Error Data:", errorData);
                    throw new Error(`Backend API error: ${errorData.error || response.statusText}. Details: ${JSON.stringify(errorData)}`);
                }

                const result = await response.json();
                console.log("[sendAICommand] Raw backend response result:", result);

                if (result.content) { // Expecting { content: "..." } from your backend
                    processAICommand(result.content); // Pass the AI's content for parsing
                } else {
                    console.error("[sendAICommand] Backend response format unexpected or empty. Result:", result);
                    throw new Error("Backend response format unexpected or empty.");
                }

            } catch (error) {
                console.error("Error communicating with backend API:", error);
                addMessageToLog('AI', `I'm sorry, I couldn't reach the AI service through your backend. Please ensure your Render backend is running and configured correctly. Error: ${error.message}`);
                speakResponse(`I'm sorry, I couldn't reach the AI service.`);
            } finally {
                sendTextCommandBtn.disabled = false;
                textCommandInput.disabled = false;
                const lastLogMessage = aiLog.lastChild;
                if (lastLogMessage && lastLogMessage.textContent.includes('AI is thinking...')) {
                    aiLog.removeChild(lastLogMessage);
                }
            }
        }

        // Function to test backend connection on load (now only logs, no UI status update)
        async function testAIConnection() {
            console.log("[testAIConnection] Attempting to test backend connection with a simple 'hello'.");

            try {
                const response = await fetch(BACKEND_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: "hello" })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.content) {
                        console.log(`[testAIConnection] Backend connection successful! AI responded (via backend): "${JSON.parse(result.content).value || 'Hello!'}"`);
                    } else {
                         console.warn('[testAIConnection] Backend responded OK, but AI content was missing or malformed.');
                    }
                } else {
                    const errorData = await response.json();
                    console.error(`[testAIConnection] Backend connection failed: Status ${response.status}. Error: ${errorData.error || response.statusText}. Check Render logs.`);
                }
            } catch (error) {
                console.error(`[testAIConnection] Backend connection failed (network error): ${error.message}. Is your Render server running?`);
            }
        }

        // Function to change the color of the selected object
        function changeObjectColor(colorValue) {
            saveSceneState(); // Save state before changing color
            const newColor = new THREE.Color(colorValue);
            let objectsToModify = [];

            // If currentlySelectedObjectsForEditing is populated, use it for batch operations
            if (currentlySelectedObjectsForEditing.length > 0) {
                console.log(`[changeObjectColor] Applying color to ${currentlySelectedObjectsForEditing.length} objects from batch selection.`);
                objectsToModify = [...currentlySelectedObjectsForEditing]; // Use spread to copy array
            } else if (selectedObject) {
                // Fallback to single selected object if no batch selection
                console.log("[changeObjectColor] Applying color to single selected object.");
                objectsToModify.push(selectedObject);
            } else {
                // If neither is selected, inform the user
                addMessageToLog('System', 'No object selected. Please select an object or use "select all" first.');
                speakResponse('No object selected. Please select an object or use select all first.');
                return;
            }

            objectsToModify.forEach(obj => {
                console.log(`[changeObjectColor] Modifying color for object: ${obj.name || obj.uuid}`); // Added log
                // Traverse children to ensure all meshes within the object/model get the color change
                obj.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        materials.forEach(material => {
                            if (material && material.isMaterial) {
                                if (material.map) {
                                    material.map.dispose();
                                    material.map = null;
                                }
                                if (material.color) {
                                    material.color.set(newColor);
                                }
                                if (material.emissive !== undefined) {
                                    material.emissive.set(0x000000);
                                    material.emissiveIntensity = 0;
                                }
                                material.needsUpdate = true;
                            }
                        });
                        // Update initialMaterial for this child mesh to reflect the new permanent color
                        if (Array.isArray(child.material)) {
                            child.userData.initialMaterial = child.material.map(mat => mat.clone());
                        } else {
                            child.userData.initialMaterial = child.material.clone();
                        }
                    }
                });
                // After changing color, update originalMaterialProperties for the current selection cycle
                // This ensures that if this object is later individually selected, its highlight reverts correctly.
                const updatedOriginalMaterials = [];
                const topLevelMaterials = Array.isArray(obj.material) ? obj.material : [obj.material];
                topLevelMaterials.forEach(mat => {
                    if (mat && mat.isMaterial) {
                        updatedOriginalMaterials.push(mat.clone());
                    }
                });
                originalMaterialProperties.set(obj.uuid, updatedOriginalMaterials);
                obj.updateMatrixWorld(true); // Ensure world matrix is updated after material change
            });

            addMessageToLog('AI', `Changed color of ${objectsToModify.length} object(s) to ${colorValue}.`);
            speakResponse(`Changed color of ${objectsToModify.length} object(s).`);
            console.log(`[changeObjectColor] Changed color of ${objectsToModify.length} object(s) to ${colorValue}.`);

            clearAllHighlights(); // This will now revert to the updated initialMaterial
            updateUndoRedoButtons(); // Update buttons after action
        }

        // Function to create a primitive shape
        function createPrimitive(type) {
            saveSceneState(); // Save state before creating primitive
            let geometry;
            let mesh;
            const material = new THREE.MeshStandardMaterial({ color: 0x1e90ff, metalness: 0.5, roughness: 0.5 });

            switch (type.toLowerCase()) {
                case 'box':
                case 'cube':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.name = 'Cube';
                    break;
                case 'sphere':
                case 'ball':
                    geometry = new THREE.SphereGeometry(0.5, 32, 32);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.name = 'Sphere';
                    break;
                case 'cylinder':
                case 'tube': // Added 'tube' as an alias
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.name = 'Cylinder';
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(0.5, 1, 32);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.name = 'Cone';
                    break;
                case 'pyramid':
                    geometry = new THREE.ConeGeometry(0.5, 1, 4); // A cone with 4 segments forms a pyramid
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.name = 'Pyramid';
                    break;
                case 'plane': // Added plane
                    geometry = new THREE.PlaneGeometry(10, 10);
                    mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: 0xcccccc, side: THREE.DoubleSide }));
                    mesh.rotation.x = -Math.PI / 2; // Orient horizontally
                    mesh.name = 'Plane';
                    break;
                case 'torus': // Added torus (donut)
                    geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.name = 'Torus';
                    break;
                default:
                    addMessageToLog('AI', `I don't know how to create a "${type}" shape. Try "box", "sphere", "cylinder", "cone", "pyramid", "plane", or "torus".`);
                    speakResponse(`I don't know how to create a ${type} shape. Try box, sphere, cylinder, cone, pyramid, plane, or torus.`);
                    return;
            }

            // Store initial material(s) for the newly created primitive
            if (Array.isArray(mesh.material)) {
                mesh.userData.initialMaterial = mesh.material.map(mat => mat.clone());
            } else {
                mesh.userData.initialMaterial = mesh.material.clone();
            }

            // Position the new object slightly in front of the camera's current target
            const positionOffset = new THREE.Vector3(0, 0, -2).applyQuaternion(camera.quaternion);
            mesh.position.copy(controls.target).add(positionOffset);
            mesh.position.y = 0.5; // Place it slightly above the grid

            scene.add(mesh);
            loadedModels.push(mesh); // Add to our list of loaded models
            addMessageToLog('AI', `Created a ${type} model.`);
            speakResponse(`Created a ${type} model.`);
            selectObject(mesh); // Select the newly created object
            updateUndoRedoButtons(); // Update buttons after action
        }


        function processAICommand(aiResponseContent) { // Now receives the content string directly
            console.log("[processAICommand] Processing AI command content:", aiResponseContent);

            let parsedResponse;
            try {
                parsedResponse = JSON.parse(aiResponseContent); // Parse the content string
                console.log("[processAICommand] Parsed AI response (JSON):", parsedResponse);

                // Handle cases where 'action' might be missing or is 'conversational'
                if (parsedResponse.action === 'conversational' || (!parsedResponse.action && parsedResponse.value)) {
                    addMessageToLog('AI', parsedResponse.value);
                    speakResponse(parsedResponse.value);
                } else if (typeof parsedResponse.action === 'string') {
                    switch (parsedResponse.action) {
                        case 'createShape':
                            if (parsedResponse.value) {
                                createPrimitive(parsedResponse.value);
                            } else {
                                addMessageToLog('AI', 'Please specify a shape type (e.g., "box", "sphere", "cylinder", "cone", "pyramid").');
                                speakResponse('Please specify a shape type like box, sphere, cylinder, cone, or pyramid.');
                            }
                            break;
                        case 'removeObject':
                            removeObject();
                            break;
                        case 'duplicateObject': // Handle duplicate command
                            console.log("[processAICommand] Duplicate command received. selectedObject is:", selectedObject ? selectedObject.name || selectedObject.uuid : 'null');
                            if (selectedObject) {
                                duplicateSelectedObject(); // This will now proceed if selectedObject is valid
                            } else {
                                // If AI tries to duplicate but nothing is selected, provide a specific error to the user
                                addMessageToLog('AI', 'I cannot duplicate. No object is currently selected. Please select an object first by clicking on it.');
                                speakResponse('No object selected to duplicate. Please click on an object first.');
                            }
                            break;
                        case 'resetView':
                            resetView();
                            break;
                        case 'showDesignInfo':
                            showDesignInfo();
                            break;
                        case 'setTransformMode':
                            if (parsedResponse.value) {
                                setTransformMode(parsedResponse.value);
                            } else {
                                addMessageToLog('AI', 'Please specify a transform mode (translate, rotate, scale).');
                                speakResponse('Please specify a transform mode like translate, rotate, or scale.');
                            }
                            break;
                        case 'listParts':
                            listParts();
                            break;
                        case 'selectPart':
                            if (parsedResponse.value) {
                                selectPartByName(parsedResponse.value);
                            } else {
                                addMessageToLog('AI', 'Please specify a part name to select.');
                                speakResponse('Please tell me which part to select.');
                            }
                            break;
                        case 'selectAll': // Handle select all command
                            highlightAllModels();
                            break;
                        case 'clearAllHighlights': // New command to clear all highlights
                            clearAllHighlights();
                            break;
                        case 'rotateAxis':
                            saveSceneState(); // Save state before rotating
                            // Determine target objects: all highlighted, or single selected
                            const objectsToRotate = [];
                            if (currentlySelectedObjectsForEditing.length > 0) {
                                console.log(`[rotateAxis] Applying rotation to ${currentlySelectedObjectsForEditing.length} objects from batch selection.`);
                                // FIX: Iterate over loadedModels and apply transformation to the top-level model
                                loadedModels.forEach(model => {
                                    if (model && model.isObject3D) { // Ensure it's a valid Three.js object
                                        objectsToRotate.push(model);
                                        console.log(`[rotateAxis] Targeting top-level model for rotation: ${model.name || model.uuid}`);
                                    }
                                });
                            } else if (selectedObject) {
                                console.log("[rotateAxis] Applying rotation to single selected object.");
                                objectsToRotate.push(selectedObject);
                                console.log(`[rotateAxis] Targeting object for rotation: ${selectedObject.name || selectedObject.uuid}`);
                            }

                            if (objectsToRotate.length > 0 && parsedResponse.value) {
                                const { axis, degrees } = parsedResponse.value;
                                const radians = THREE.MathUtils.degToRad(degrees || 90);
                                objectsToRotate.forEach(obj => {
                                    obj.rotation[axis] += radians; // Direct access using bracket notation
                                    obj.updateMatrixWorld(true); // Ensure world matrix is updated for correct rendering
                                });
                                addMessageToLog('AI', `Rotated ${objectsToRotate.length} object(s) by ${degrees || 90} degrees around ${axis || 'y'}-axis.`);
                                speakResponse(`Rotated ${objectsToRotate.length} object(s).`);
                                clearAllHighlights(); // Clear highlights after batch operation
                            } else {
                                addMessageToLog('System', 'No object selected or highlighted, or invalid rotation command.');
                                speakResponse('No object selected or highlighted, or invalid rotation command.');
                            }
                            updateUndoRedoButtons(); // Update buttons after action
                            break;
                        case 'scale':
                            saveSceneState(); // Save state before scaling
                            // Determine target objects: all highlighted, or single selected
                            const objectsToScale = [];
                            if (currentlySelectedObjectsForEditing.length > 0) {
                                console.log(`[scale] Applying scale to ${currentlySelectedObjectsForEditing.length} objects from batch selection.`);
                                // FIX: Iterate over loadedModels and apply transformation to the top-level model
                                loadedModels.forEach(model => {
                                    if (model && model.isObject3D) {
                                        objectsToScale.push(model);
                                        console.log(`[scale] Targeting top-level model for scaling: ${model.name || model.uuid}`);
                                    }
                                });
                            } else if (selectedObject) {
                                console.log("[scale] Applying scale to single selected object.");
                                objectsToScale.push(selectedObject);
                                console.log(`[scale] Targeting object for scaling: ${selectedObject.name || selectedObject.uuid}`);
                            }

                            if (objectsToScale.length > 0 && parsedResponse.value) {
                                const factor = parsedResponse.value;
                                objectsToScale.forEach(obj => {
                                    obj.scale.multiplyScalar(factor);
                                    obj.updateMatrixWorld(true); // Ensure world matrix is updated for correct rendering
                                });
                                addMessageToLog('AI', `Scaled ${objectsToScale.length} object(s) by a factor of ${factor}.`);
                                speakResponse(`Scaled ${objectsToScale.length} object(s).`);
                                clearAllHighlights(); // Clear highlights after batch operation
                            } else {
                                addMessageToLog('System', 'No object selected or highlighted, or invalid scale command.');
                                speakResponse('No object selected or highlighted, or invalid scale command.');
                            }
                            updateUndoRedoButtons(); // Update buttons after action
                            break;
                        case 'translate':
                            saveSceneState(); // Save state before translating
                            // Determine target objects: all highlighted, or single selected
                            const objectsToTranslate = [];
                            if (currentlySelectedObjectsForEditing.length > 0) {
                                console.log(`[translate] Applying translation to ${currentlySelectedObjectsForEditing.length} objects from batch selection.`);
                                // FIX: Iterate over loadedModels and apply transformation to the top-level model
                                loadedModels.forEach(model => {
                                    if (model && model.isObject3D) {
                                        objectsToTranslate.push(model);
                                        console.log(`[translate] Targeting top-level model for translation: ${model.name || model.uuid}`);
                                    }
                                });
                            } else if (selectedObject) {
                                console.log("[translate] Applying translation to single selected object.");
                                objectsToTranslate.push(selectedObject);
                                console.log(`[translate] Targeting object for translation: ${selectedObject.name || selectedObject.uuid}`);
                            }

                            if (objectsToTranslate.length > 0 && parsedResponse.value) {
                                const { x, y, z } = parsedResponse.value;
                                objectsToTranslate.forEach(obj => {
                                    obj.position.x += (x || 0);
                                    obj.position.y += (y || 0);
                                    obj.position.z += (z || 0);
                                    obj.updateMatrixWorld(true); // Ensure world matrix is updated for correct rendering
                                });
                                addMessageToLog('AI', `Moved ${objectsToTranslate.length} object(s) by X:${x || 0}, Y:${y || 0}, Z:${z || 0}.`);
                                speakResponse(`Moved ${objectsToTranslate.length} object(s).`);
                                clearAllHighlights(); // Clear highlights after batch operation
                            } else {
                                addMessageToLog('System', 'No object selected or highlighted, or invalid translate command.');
                                speakResponse('No object selected or highlighted, or invalid translate command.');
                            }
                            updateUndoRedoButtons(); // Update buttons after action
                            break;
                        case 'changeColor':
                            if (parsedResponse.value) {
                                changeObjectColor(parsedResponse.value);
                            } else {
                                addMessageToLog('AI', 'Please specify a color value (e.g., "red", "#FF0000").');
                                speakResponse('Please specify a color value.');
                            }
                            break;
                        case 'error':
                            addMessageToLog('AI', parsedResponse.value || 'An unknown error occurred.'); // Use parsedResponse.value for error messages
                            speakResponse(parsedResponse.value || 'An unknown error occurred.');
                            break;
                        default:
                            addMessageToLog('AI', `Understood: "${parsedResponse.action}". However, I don't know how to perform this action.`);
                            speakResponse(`I understand, but I don't know how to perform ${parsedResponse.action}.`);
                    }
                } else if (parsedResponse.message) {
                    addMessageToLog('AI', parsedResponse.message);
                    speakResponse(parsedResponse.message);
                } else {
                    addMessageToLog('AI', `Unexpected AI response format: ${aiResponseContent}`);
                    speakResponse('I received an unexpected response.');
                }
            } catch (jsonError) {
                console.error("Failed to parse AI response as JSON:", jsonError, "Raw Response (for parsing error):", aiResponseContent); // Specific log for parsing errors
                addMessageToLog('AI', `I received an uninterpretable response from the AI: "${aiResponseContent.substring(0, 100)}...". Please check the console for full details.`);
                speakResponse('I received an uninterpretable response.');
            }
        }

        // Voice input integration
        if ('webkitSpeechRecognition' in window) {
            recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isVoiceAssistActive = true;
                integratedVoiceBtn.classList.add('active-voice-btn');
                addMessageToLog('System', 'Listening for voice commands...');
            };

            recognition.onresult = (event) => {
                const command = event.results[0][0].transcript;
                addMessageToLog('System', `You said: "${command}"`);
                sendAICommand(command);
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                addMessageToLog('System', `Voice command error: ${event.error}`);
                speakResponse("I didn't catch that. Could you please repeat?");
                integratedVoiceBtn.classList.remove('active-voice-btn');
                isVoiceAssistActive = false;
            };

            recognition.onend = () => {
                integratedVoiceBtn.classList.remove('active-voice-btn');
                isVoiceAssistActive = false;
                addMessageToLog('System', 'Voice command ended.');
            };

            integratedVoiceBtn.addEventListener('click', () => {
                if (isVoiceAssistActive) {
                    stopVoiceAssist();
                } else {
                    startVoiceAssist();
                }
            });
        } else {
            integratedVoiceBtn.style.display = 'none'; // Hide button if API not supported
            addMessageToLog('System', 'Voice recognition not supported in this browser.');
        }

        function startVoiceAssist() {
            if (recognition && !isVoiceAssistActive) {
                recognition.start();
            }
        }

        function stopVoiceAssist() {
            if (recognition && isVoiceAssistActive) {
                recognition.stop();
            }
        }

        // Text-to-speech integration
        if ('speechSynthesis' in window) {
            synth = window.speechSynthesis;
        } else {
            console.warn('Text-to-speech not supported in this browser.');
        }

        function speakResponse(text) {
            if (synth) {
                const utterance = new SpeechSynthesisUtterance(text);
                synth.speak(utterance);
            }
        }
        // Send text command via input field
        sendTextCommandBtn.addEventListener('click', () => {
            const command = textCommandInput.value.trim();
            if (command) {
                addMessageToLog('User', command); // Add user message to log immediately
                sendAICommand(command);
                textCommandInput.value = ''; // Clear input after sending
            }
        });

        // Allow sending command by pressing Enter in the input field
        textCommandInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default Enter key behavior (e.g., new line in textarea)
                sendTextCommandBtn.click();
            }
        });

        // Handle window resizing for Three.js canvas
        function onWindowResize() {
            if (camera && renderer && cadCanvas) {
                const viewerDiv = cadCanvas.parentElement;
                camera.aspect = viewerDiv.clientWidth / viewerDiv.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(viewerDiv.clientWidth, viewerDiv.clientHeight);
                updateDynamicGrid(); // Update grid on resize as well
                // No need to call resetView() here, as it can be jarring on every resize.
                // The user can use the "Fit All" button or AI command.
            }
             // Update viewAxesHelper renderer size on window resize
            if (viewAxesRenderer && viewAxesContainer) {
                viewAxesRenderer.setSize(viewAxesContainer.clientWidth, viewAxesContainer.clientHeight);
                viewAxesCamera.aspect = viewAxesContainer.clientWidth / viewAxesContainer.clientHeight;
                viewAxesCamera.updateProjectionMatrix();
            }
        }

        window.addEventListener('resize', onWindowResize, false);

        // Function to handle tab switching (AI Chat / Code Editor)
        function setActiveTab(tabName) {
            // Remove 'active' class from all tab buttons and content
            // Ensure we only affect the tab buttons within the right-panel
            document.querySelectorAll('.right-panel .tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.right-panel .tab-content').forEach(content => content.classList.remove('active'));

            // Add 'active' class to the clicked tab button and corresponding content
            if (tabName === 'chat') {
                chatTabButton.classList.add('active');
                chatContent.classList.add('active');
                speakResponse('Switched to AI chat.');
            } else if (tabName === 'codeEditor') {
                codeEditorTabButton.classList.add('active');
                codeEditorContent.classList.add('active');
                speakResponse('Switched to code editor.');
            }
        }

        // Event listeners for tab buttons (now that setActiveTab is global)
        chatTabButton.addEventListener('click', () => setActiveTab('chat'));
        codeEditorTabButton.addEventListener('click', () => setActiveTab('codeEditor'));


        // Initialize scene when the window loads
        window.onload = () => {
            initScene();
            // Set initial CSS for the CAD viewer background
            cadViewer.style.backgroundColor = '#FFFFFF';
            cadViewer.style.backgroundImage = 'repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(0,0,0,0.1) 20px), repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(0,0,0,0.1) 20px)';
            cadViewer.style.backgroundSize = '20px 20px';

            // Ensure the upload page is active and editor page is inactive on initial load
            uploadPage.classList.add('page-active');
            uploadPage.classList.remove('page-inactive');
            editorPage.classList.add('page-inactive');
            editorPage.classList.remove('page-active');

            // Explicitly hide dropZone and loadingMsg on initial load
            dropZone.style.display = 'none';
            dropZone.style.pointerEvents = 'none';
            loadingMsg.style.display = 'none';

            // Automatically test AI connection on load
            testAIConnection(); // Still call to log backend status to console

            // Removed event listeners for view control buttons as the HTML is removed
            // topViewBtn.addEventListener('click', setTopView);
            // bottomViewBtn.addEventListener('click', setBottomView);
            // frontViewBtn.addEventListener('click', setFrontView);
            // backViewBtn.addEventListener('click', setBackView);
            // rightViewBtn.addEventListener('click', setRightView);
            // leftViewBtn.addEventListener('click', setLeftView);
            // isometricViewBtn.addEventListener('click', setIsometricView);
            // fitAllViewBtn.addEventListener('click', resetView);

            // Add event listener for object color change
            applyObjectColorBtn.addEventListener('click', () => {
                const color = objectColorPicker.value;
                changeObjectColor(color);
            });

            // Initial message to guide the user on the upload page
            addMessageToLog('System', 'Welcome to the AI VR CAD Editor! Please choose an option above to get started: "Create Empty Model", "Edit Existing Model" (to upload a file), or "Load Random Model".');

            // Initial save of the scene state after everything is initialized
            saveSceneState();
        };

    </script>
</body>
</html>
