<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI VR CAD Editor</title>
    <!-- Using Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Global Styles */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            /* Authentic Fusion-like pure white background for the whole app */
            background-color: #FFFFFF; /* Pure white base color for Fusion 360 */
            background-image: repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(0,0,0,0.1) 20px), /* Visible darker grid lines */
            repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(0,0,0,0.1) 20px);\
            background-size: 20px 20px; /* Size of each grid cell */
            overflow: hidden; /* Keep overflow hidden for main body */
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            background-color: #1a202c; /* Darker, more professional header */
            padding: 15px 25px;
            color: #e2e8f0; /* Lighter text for contrast */
            text-align: center;
            font-size: 2.2rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-shrink: 0;
            height: 70px;
            box-sizing: border-box;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            position: relative; /* For API key status positioning */
        }

            header svg {
                height: 35px;
                width: 35px;
                fill: #DAA520; /* Accent color for the logo - Dark Yellow */
                transition: transform 0.3s ease;
            }

            header:hover svg {
                transform: rotate(5deg) scale(1.05);
            }

        /* Page Container & Transitions */
        .page-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            width: 100%;
            position: relative;
        }

        .page {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.6s ease-in-out, transform 0.6s ease-in-out;
            transform: translateX(0);
        }

        .page-active {
            opacity: 1;
            pointer-events: auto !important; /* Ensure it's clickable */
            z-index: 1;
        }

        .page-inactive {
            opacity: 0;
            pointer-events: none;
            z-index: 0;
            transform: translateX(-100%);
        }

        /* Upload Page */
        #uploadPage {
            background-color: transparent; /* Changed to transparent to show body background */
            color: #333;
            padding: 20px;
            box-sizing: border-box;
        }

        .upload-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            background: #ffffff;
            padding: 50px 60px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 500px;
            text-align: center;
        }

            .upload-content h2 {
                color: #1a202c;
                margin-bottom: 15px;
                font-size: 2.2em;
                font-weight: 700;
                display: flex; /* Enable flex for logo and text alignment */
                align-items: center;
                justify-content: center;
                gap: 10px; /* Space between logo and text */
            }

                .upload-content h2 svg {
                    height: 35px;
                    width: 35px;
                    fill: #DAA520; /* Accent color for the logo - Dark Yellow */
                }


        #dropZone {
            width: 100%;
            height: 180px;
            border: 3px dashed #a0aec0;
            border-radius: 10px;
            display: none; /* Initially hidden */
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #4a5568;
            cursor: pointer;
            transition: border-color 0.4s ease, background-color 0.4s ease, color 0.4s ease;
            font-size: 1.2em;
            background-color: #f7fafc;
            font-weight: 600;
            position: relative; /* Keep relative for internal positioning if needed later */
            overflow: hidden;
            pointer-events: none; /* Crucial: ensure it doesn't block clicks when hidden */
        }

            #dropZone:hover {
                border-color: #DAA520; /* Accent color on hover - Dark Yellow */
                background-color: #FFF8DC; /* Light yellow background on hover */
                color: #B8860B; /* Darker yellow text */
            }

        /* fileInput is now handled by inline style and pointer-events on dropZone */

        .button-group {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            gap: 15px; /* Space between buttons */
            margin-top: 25px;
            width: 100%; /* Ensure buttons take full width of upload-content */
        }

        .button {
            padding: 14px 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 100%; /* Make buttons full width */
            box-sizing: border-box; /* Include padding in width */
        }

            .button.primary {
                background-color: #DAA520; /* Primary button - Dark Yellow */
                color: white;
            }

                .button.primary:hover {
                    background-color: #B8860B; /* Darker yellow on hover */
                    transform: translateY(-3px);
                    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
                }

            .button.secondary {
                background-color: #6c757d;
                color: white;
            }

                .button.secondary:hover {
                    background-color: #5a6268;
                    transform: translateY(-3px);
                    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
                }

        #loadingMsg {
            display: none;
            margin-top: 25px;
            color: #DAA520; /* Dark Yellow */
            font-size: 1.15em;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        /* Editor Page */
        #editorPage {
            background-color: #FFFFFF; /* Pure white background - authentic Fusion */
            display: flex;
            flex-direction: row;
            justify-content: flex-start;
            align-items: stretch;
            padding: 0;
            box-sizing: border-box;
            position: relative;
            flex-grow: 1; /* Ensure editor page takes full height after header */
        }

        /* Right Panel for Chat and Code Editor */
        .right-panel {
            width: 350px;
            background-color: #1a202c;
            padding: 25px;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #2d3748;
            box-shadow: -4px 0 10px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
            color: #e2e8f0;
            height: 100%; /* Ensure right-panel takes full available height */
            box-sizing: border-box; /* Include padding in height calculation */
        }

            .right-panel h2 {
                color: #ffffff;
                margin-bottom: 25px;
                font-size: 1.9em;
                border-bottom: 2px solid #DAA520; /* Accent color border - Dark Yellow */
                padding-bottom: 12px;
                font-weight: 700;
            }

        /* Tab buttons for chat/code editor */
        .tab-buttons {
            display: flex;
            align-items: center; /* Align items to center vertically */
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden;
            background-color: #2d3748;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            padding: 5px; /* Added padding to contain the circular button better */
            box-sizing: border-box;
            gap: 5px; /* Reduced gap between buttons for tighter packing */
        }

        .tab-button {
            flex-grow: 1;
            padding: 10px 15px;
            border: none;
            background-color: transparent;
            color: #a0aec0;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
            text-align: center;
            border-radius: 8px; /* Apply border-radius to individual buttons */
        }

            .tab-button:hover {
                background-color: #3a414e;
                color: #e2e8f0;
            }

            .tab-button.active {
                background-color: #DAA520; /* Active tab button - Dark Yellow */
                color: white;
                box-shadow: 0 2px 5px rgba(218, 165, 32, 0.3); /* Dark Yellow shadow */
            }

        /* Small circular button for "Back to Upload" */
        #backToUploadCircleButton {
            width: 40px; /* Small size */
            height: 40px; /* Small size */
            border-radius: 50%; /* Circular shape */
            background-color: #DAA520; /* Dark Yellow */
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em; /* Smaller font size if text is present */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
            flex-shrink: 0; /* Prevent shrinking */
        }

            #backToUploadCircleButton:hover {
                background-color: #B8860B; /* Darker yellow on hover */
                transform: translateY(-2px);
                box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
            }

            #backToUploadCircleButton svg {
                fill: #FFFFFF;
                height: 20px;
                width: 20px;
            }


        /* Tab content areas */
        .tab-content {
            flex-grow: 1; /* Ensure tab content grows to fill available space */
            display: none; /* Hidden by default */
            flex-direction: column; /* Ensure content stacks vertically */
            padding-top: 5px; /* Small padding for content */
            height: 100%; /* Crucial: Make sure tab-content takes full height of its parent */
            box-sizing: border-box; /* Include padding in height */
        }

            .tab-content.active {
                display: flex; /* Show active tab content */
            }

        #chatContent {
            /* No changes needed here, as parent .tab-content and children #aiLog and .ai-input-group handle flex distribution */
        }

        #codeEditorContent {
            height: 100%; /* Take full height of parent when active */
        }

        #cadViewer {
            flex-grow: 1;
            background-color: #FFFFFF; /* Pure white background - authentic Fusion */
            position: relative;
        }

        #cadCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #aiLog {
            flex-grow: 1; /* Allow aiLog to grow and take available space */
            flex-shrink: 1; /* Allow aiLog to shrink if needed */
            background-color: #2d3748;
            border-radius: 10px;
            padding: 15px;
            color: #e2e8f0;
            overflow-y: auto; /* This should handle scrolling for the chat history */
            line-height: 1.5;
            margin-bottom: 10px; /* Add some space between log and input */
            min-height: 50px; /* Ensure a minimum height for the log */
            flex-basis: 0; /* Added to ensure it respects flex-grow properly */
        }

        .user-message, .ai-response, .system-message {
            padding: 8px 12px;
            border-radius: 12px;
            margin-bottom: 8px;
            word-wrap: break-word; /* Ensure long words wrap */
            max-width: 85%; /* Slightly reduce max-width for better look */
        }

        .user-message {
            background-color: #DAA520; /* Accent color for user messages - Dark Yellow */
            color: white;
            text-align: right;
            align-self: flex-end;
            margin-left: auto;
        }

        .ai-response {
            background-color: #4a5568;
            color: #e2e8f0;
            text-align: left;
            align-self: flex-start;
            margin-right: auto;
        }

        .system-message {
            background-color: #2d3748;
            color: #cbd5e0;
            text-align: center;
            font-style: italic;
            border-bottom: 1px dashed #4a5568;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        /* Updated AI Input Group for integrated voice button */
        .ai-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
            padding-top: 10px; /* Add some padding above the input group */
            box-sizing: border-box;
            /* Ensure it stays at the bottom */
            position: sticky;
            bottom: 0;
            background-color: #1a202c; /* Match right panel background */
            z-index: 10; /* Ensure it's above chat log content */
            padding-bottom: 10px; /* Add padding at the very bottom */
        }

        #textCommandInput {
            flex-grow: 1;
            padding: 12px;
            border: 1px solid #4a5568;
            border-radius: 25px;
            background-color: #2d3748;
            color: #e2e8f0;
            font-size: 1em;
            outline: none;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

            #textCommandInput::placeholder {
                color: #a0aec0;
            }

            #textCommandInput:focus {
                border-color: #DAA520; /* Accent color on focus - Dark Yellow */
                box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3), 0 0 0 2px rgba(218, 165, 32, 0.3); /* Focus ring - Dark Yellow */
            }

        #sendTextCommandBtn {
            padding: 12px 20px;
            background-color: #DAA520; /* Send button - Dark Yellow */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

            #sendTextCommandBtn:hover {
                background-color: #B8860B; /* Darker yellow on hover */
                transform: translateY(-2px);
                box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
            }

        /* New style for the integrated microphone button (now a separate button) */
        #integratedVoiceBtn {
            background-color: #3a414e;
            border: none;
            cursor: pointer;
            padding: 10px;
            border-radius: 50%;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 48px;
            width: 48px;
            box-sizing: border-box;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }

            #integratedVoiceBtn svg {
                fill: #FFFFFF; /* Changed fill to white for visibility */
                height: 24px;
                width: 24px;
                transition: fill 0.3s ease;
            }

            #integratedVoiceBtn:hover {
                background-color: #4a5568;
                transform: translateY(-2px);
                box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
            }

                #integratedVoiceBtn.active-voice-btn {
                    background-color: #e53e3e; /* Red when active */
                    box-shadow: 0 0 0 4px rgba(229, 62, 62, 0.4); /* Red glow when active */
                }

                #integratedVoiceBtn.active-voice-btn svg {
                    fill: white;
                }

        /* Code Editor Specific Styles */
        #cssCodeEditor {
            width: 100%;
            flex-grow: 1; /* Allows it to fill available height */
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Monaspace Neon', 'Fira Code', 'Consolas', monospace; /* Monospace font for code */
            font-size: 0.9em;
            color: #e2e8f0;
            resize: vertical; /* Allow vertical resizing */
            min-height: 150px;
            box-sizing: border-box; /* Include padding in width/height */
            margin-bottom: 15px; /* Space before button */
            outline: none;
        }

            #cssCodeEditor:focus {
                border-color: #DAA520; /* Dark Yellow */
                box-shadow: 0 0 0 2px rgba(218, 165, 32, 0.3); /* Dark Yellow */
            }

        #applyCssButton {
            width: 100%;
            padding: 12px 20px;
            background-color: #28a745; /* Green for apply/preview */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
        }

            #applyCssButton:hover {
                background-color: #218838;
                transform: translateY(-2px);
                box-shadow: 0 5px 10px rgba(0, 0, 0, 0.25);
            }

        /* New View Controls Section - REMOVED */
        /* .view-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #2d3748;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .view-control-button {
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .view-control-button:hover {
            background-color: #DAA520;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        } */

        /* Style for the static view axes helper */
        #viewAxesContainer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px; /* Smaller size for the helper */
            height: 100px;
            z-index: 5; /* Ensure it's above the CAD canvas */
            pointer-events: auto; /* Enable clicks on this container */
            background-color: rgba(0, 0, 0, 0.3); /* Semi-transparent background */
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease; /* For click feedback */
        }

        /* Object Properties Section Styles */
        .object-properties-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #2d3748;
            display: flex;
            flex-direction: column;
            gap: 10px;
            color: #e2e8f0;
        }

        .object-properties-controls h3 {
            color: #ffffff;
            font-size: 1.2em;
            margin-bottom: 10px;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 5px;
        }

        .object-properties-controls .property-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .object-properties-controls label {
            flex-shrink: 0;
            font-weight: 600;
        }

        #objectColorPicker {
            flex-grow: 1;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 80px; /* Fixed width for color picker */
            height: 35px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            overflow: hidden; /* Hide default border */
        }

        #objectColorPicker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        #objectColorPicker::-webkit-color-swatch {
            border: 1px solid #4a5568;
            border-radius: 5px;
        }

        #objectColorPicker::-moz-color-swatch-wrapper {
            padding: 0;
        }

        #objectColorPicker::-moz-color-swatch {
            border: 1px solid #4a5568;
            border-radius: 5px;
        }

        #applyObjectColorBtn {
            /* Reuse view-control-button styles */
            padding: 8px 15px;
            font-size: 0.9em;
        }
    </style>
    <!-- Import Map for ES Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <header>
        <!-- New Innovative Logo SVG -->
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 1L2 6v12l10 5 10-5V6L12 1zm0 2.31L18.47 6 12 9.31 5.53 6 12 3.31zM4 7.69l6 3.15v6.52L4 13.84V7.69zm8 11.01L6.47 16 12 12.69l5.53 3.31L12 18.7zM20 13.84l-6 3.15V10.84l6-3.15v6.15z" />
            <circle cx="12" cy="12" r="2" fill="#DAA520" /> <!-- Dark Yellow -->
            <path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" fill="#fff" />
        </svg>
        AI VR CAD Editor
        <!-- Removed API Key Status Indicator -->
    </header>

    <div class="page-container">
        <section id="uploadPage" class="page page-active">
            <div class="upload-content">
                <h2>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 1L2 6v12l10 5 10-5V6L12 1zm0 2.31L18.47 6 12 9.31 5.53 6 12 3.31zM4 7.69l6 3.15v6.52L4 13.84V7.69zm8 11.01L6.47 16 12 12.69l5.53 3.31L12 18.7zM20 13.84l-6 3.15V10.84l6-3.15v6.15z" />
                        <circle cx="12" cy="12" r="2" fill="#DAA520" />
                        <path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" fill="#fff" />
                    </svg>
                    AI VR CAD Editor
                </h2>
                <div class="button-group">
                    <button class="button primary" id="createNewEmptyModelButton">Create Empty Model</button>
                    <button class="button primary" id="editExistingModelButton">Edit Existing Model</button>
                    <button class="button secondary" id="loadRandomModelButton">Load Random Model</button>
                </div>
                <div id="dropZone">
                    Drag and Drop your .gltf or .glb file(s) here
                </div>
                <p id="loadingMsg">Loading model, please wait...</p>
                <!-- The file input is kept here, hidden, as it's triggered programmatically -->
                <input type="file" id="fileInput" accept=".gltf,.glb" style="display: none;" />
            </div>
        </section>

        <section id="editorPage" class="page page-inactive">
            <main id="cadViewer">
                <canvas id="cadCanvas"></canvas>
                <div id="viewAxesContainer"></div> <!-- Container for the static view axes -->
            </main>

            <!-- NEW: Right-side chat panel with updated buttons -->
            <div class="right-panel">
                <div class="tab-buttons">
                    <!-- Small circular "Back to Upload" button -->
                    <button id="backToUploadCircleButton" onclick="window.goBack()">
                        <!-- Left arrow SVG -->
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#FFFFFF"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z" /></svg>
                    </button>
                    <button class="tab-button active" id="uploadNewFileButton">Upload New File</button>
                    <button class="tab-button" id="saveButton">Save</button>
                </div>

                <!-- Removed View Controls Section -->
                <!-- <div class="view-controls">
                    <button class="view-control-button" id="topViewBtn">Top View</button>
                    <button class="view-control-button" id="bottomViewBtn">Bottom View</button>
                    <button class="view-control-button" id="frontViewBtn">Front View</button>
                    <button class="view-control-button" id="backViewBtn">Back View</button>
                    <button class="view-control-button" id="rightViewBtn">Right View</button>
                    <button class="view-control-button" id="leftViewBtn">Left View</button>
                    <button class="view-control-button" id="isometricViewBtn">Isometric View</button>
                    <button class="view-control-button" id="fitAllViewBtn">Fit All</button>
                </div> -->

                <!-- Object Properties Section -->
                <div class="object-properties-controls">
                    <h3>Object Properties</h3>
                    <div class="property-group">
                        <label for="objectColorPicker">Color:</label>
                        <input type="color" id="objectColorPicker" value="#1e90ff" />
                        <button class="view-control-button" id="applyObjectColorBtn">Apply Color</button>
                    </div>
                    <!-- More properties can be added here later -->
                </div>

                <!-- Chat Content remains visible by default -->
                <div id="chatContent" class="tab-content active">
                    <div id="aiLog">
                        <p class="system-message">System: AI Chat Log Initialized.</p>
                    </div>
                    <div class="ai-input-group">
                        <input type="text" id="textCommandInput" placeholder="Type AI command or question..." />
                        <button id="integratedVoiceBtn">
                            <!-- Changed fill to white for visibility -->
                            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#FFFFFF"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.2-3c0 3.53-2.64 6.44-6.2 6.93V21h-2v-3.07c-3.56-.49-6.2-3.4-6.2-6.93h-2c0 4.17 3.13 7.62 7.2 8.15V23h4v-2.85c4.07-.53 7.2-3.98 7.2-8.15h-2z" /></svg>
                        </button>
                        <button id="sendTextCommandBtn">Send</button>
                    </div>
                </div>

                <!-- Code Editor Content is now hidden by default without a direct button -->
                <div id="codeEditorContent" class="tab-content">
                    <textarea id="cssCodeEditor" placeholder="Enter CSS for CAD viewer background..."></textarea>
                    <button id="applyCssButton">Preview CSS</button>
                </div>
            </div>
        </section>
    </div>

    <script type="module">
        // Import Three.js and its modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // Global map to store dropped files by their relative path (e.g., "scene.bin", "textures/image.png")
        const droppedFileBlobs = new Map();

        // List of random GLB model URLs
        const RANDOM_MODEL_URLS = [
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Box/glTF-Binary/Box.glb',
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb',
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/CesiumMilkTruck/glTF-Binary/CesiumMilkTruck.glb',
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Avocado/glTF-Binary/Avocado.glb',
            'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb'
        ];

        let uploadedFile = null, scene, camera, renderer, controls;
        let recognition;
        let synth;
        let isVoiceAssistActive = false;
        let raycaster;
        let mouse;
        let selectedObject = null; // This will hold the currently selected THREE.Mesh part
        // Stores original material properties for deselection, now includes color and emissive
        const originalMaterialProperties = new Map(); // Stores { color?: THREE.Color, emissive?: THREE.Color, emissiveIntensity?: number }
        let transformControls;

        // Variables for dynamic grid
        let currentGridHelper = null;
        let currentGridLabels = [];

        // Global array to store all loaded GLTF scenes
        let loadedModels = []; // This will now hold all top-level GLTF scenes

        // New scene and camera for the static view axes helper
        let viewAxesScene, viewAxesCamera, viewAxesRenderer;
        let viewAxesHelper; // The actual AxesHelper object

        // Get references to HTML elements
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropZone');
        const loadingMsg = document.getElementById('loadingMsg');
        const uploadPage = document.getElementById('uploadPage');
        const editorPage = document.getElementById('editorPage');
        const integratedVoiceBtn = document.getElementById('integratedVoiceBtn');
        const aiLog = document.getElementById('aiLog');
        const textCommandInput = document.getElementById('textCommandInput');
        const sendTextCommandBtn = document.getElementById('sendTextCommandBtn');
        const cadCanvas = document.getElementById('cadCanvas');
        const cadViewer = document.getElementById('cadViewer'); // Reference to the cadViewer div
        const viewAxesContainer = document.getElementById('viewAxesContainer'); // Container for the static view axes

        // New button references on the upload page
        const loadRandomModelButton = document.getElementById('loadRandomModelButton');
        const createNewEmptyModelButton = document.getElementById('createNewEmptyModelButton');
        const editExistingModelButton = document.getElementById('editExistingModelButton');

        // Updated button references on editor page
        const uploadNewFileButton = document.getElementById('uploadNewFileButton');
        const saveButton = document.getElementById('saveButton');
        const chatContent = document.getElementById('chatContent');
        const codeEditorContent = document.getElementById('codeEditorContent');
        const cssCodeEditor = document.getElementById('cssCodeEditor');
        const applyCssButton = document.getElementById('applyCssButton');

        // New view control buttons - these are now unused in the HTML but kept for reference if AI commands use them
        const topViewBtn = document.getElementById('topViewBtn');
        const bottomViewBtn = document.getElementById('bottomViewBtn');
        const frontViewBtn = document.getElementById('frontViewBtn');
        const backViewBtn = document.getElementById('backViewBtn');
        const rightViewBtn = document.getElementById('rightViewBtn');
        const leftViewBtn = document.getElementById('leftViewBtn');
        const isometricViewBtn = document.getElementById('isometricViewBtn');
        const fitAllViewBtn = document.getElementById('fitAllViewBtn');

        // New object properties UI elements
        const objectColorPicker = document.getElementById('objectColorPicker');
        const applyObjectColorBtn = document.getElementById('applyObjectColorBtn');


        // --- Expose functions globally for HTML onclick attributes ---
        window.removeObject = removeObject;
        window.resetView = resetView;
        window.showDesignInfo = showDesignInfo;
        window.goBack = goBack;
        window.selectPartByName = selectPartByName;
        window.setTransformMode = setTransformMode;
        window.listParts = listParts;
        window.saveModel = saveModel; // Expose saveModel globally

        // --- Event Listeners for new buttons ---
        // The "Upload New File" button now directly triggers the file input click
        uploadNewFileButton.addEventListener('click', () => {
            console.log("[Upload New File] button clicked."); // Debug log
            fileInput.click(); // Programmatically click the hidden file input
            addMessageToLog('System', 'Clicking "Upload New File" will open file dialog to add another model to the scene.');
        });
        saveButton.addEventListener('click', () => {
            console.log("[Save] button clicked."); // Debug log
            saveModel();
        });

        // --- New Event Listeners for Upload Page Buttons ---
        loadRandomModelButton.addEventListener('click', () => {
            console.log("[Load Random Model] button clicked. Calling goToEditor('random')."); // Added log
            uploadedFile = null; // Ensure no previous file is considered for explicit upload
            goToEditor('random'); // Go to editor and load a random model
        });

        createNewEmptyModelButton.addEventListener('click', () => {
            console.log("[Create Empty Model] button clicked. Calling goToEditor('empty')."); // Added log
            uploadedFile = null; // Ensure no previous file is considered
            goToEditor('empty'); // Go to editor with an empty scene
        });

        editExistingModelButton.addEventListener('click', () => {
            console.log("[Edit Existing Model] button clicked. Opening file dialog."); // Log for debugging
            // Do NOT show dropZone or loadingMsg here. The fileInput 'change' listener will handle cleanup.
            fileInput.click(); // Programmatically click the hidden file input
            addMessageToLog('System', 'Please select a .gltf or .glb file.');
        });


        // --- Placeholder Save Model Function ---
        function saveModel() {
            addMessageToLog('System', 'Save functionality is a placeholder. To implement actual model saving (e.g., to GLTF/GLB), a GLTFExporter would be required, which involves more complex Three.js serialization.');
            speakResponse('Save feature is not fully implemented yet.');
            console.warn("Save Model: Placeholder function executed. Actual GLTF/GLB export not implemented.");
        }

        // --- Apply CSS Function (remains the same, but now accessed via AI command or direct console) ---
        applyCssButton.addEventListener('click', () => {
            console.log("[Apply CSS] button clicked."); // Debug log
            const cssText = cssCodeEditor.value;
            try {
                // Clear existing inline styles to prevent conflicts
                cadViewer.style.cssText = '';

                // Apply the new CSS properties
                const lines = cssText.split(';');
                lines.forEach(line => {
                    const parts = line = line.split(':');
                    if (parts.length === 2) {
                        const prop = parts[0].trim();
                        const value = parts[1].trim();
                        if (prop && value) {
                            cadViewer.style[prop] = value;
                        }
                    }
                });
                addMessageToLog('System', 'CAD viewer background CSS applied successfully.');
            } catch (error) {
                addMessageToLog('System', `Error applying CSS: ${error.message}`);
                console.error("Error applying CSS:", error);
            }
        });


        // --- File Input and Page Navigation ---
        dropZone.addEventListener('dragover', e => {
            e.preventDefault();
            dropZone.textContent = 'Release to drop your .gltf or .glb file(s)';
            dropZone.style.borderColor = '#007bff';
            dropZone.style.display = 'flex'; // Show dropZone on dragover
            dropZone.style.pointerEvents = 'auto'; // Enable pointer events
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.textContent = 'Drag and Drop your .gltf or .glb file(s) here';
            dropZone.style.borderColor = '#a0aec0';
            dropZone.style.display = 'none'; // Hide dropZone on dragleave
            dropZone.style.pointerEvents = 'none'; // Disable pointer events
        });
        dropZone.addEventListener('drop', async e => {
            e.preventDefault();
            dropZone.textContent = 'Processing files...';
            dropZone.style.borderColor = '#a0aec0';
            loadingMsg.textContent = 'Processing dropped files...';
            loadingMsg.style.color = '#007bff';
            loadingMsg.style.display = 'block';

            // Always hide dropZone after a drop attempt, regardless of outcome
            dropZone.style.display = 'none';
            dropZone.style.pointerEvents = 'none';


            // When dropping, assume it's a new set of files for a new model
            // If already in editor, this means adding a new model. If on upload page, it's the first model.
            // Clear previous single-file context (important for correct URL resolution)
            droppedFileBlobs.clear();
            let mainModelFile = null;

            console.log("[Drop Handler] Drop event detected. Items:", e.dataTransfer.items);
            console.log("[Drop Handler] Files:", e.dataTransfer.files);

            async function readDroppedFiles(entry, path) {
                if (entry.isFile) {
                    const file = await new Promise(resolve => entry.file(resolve));
                    const fullPath = path ? `${path}/${file.name}` : file.name;
                    droppedFileBlobs.set(fullPath, file);
                    console.log(`[Drop Handler] Stored file: ${fullPath}, Type: ${file.type}, Size: ${file.size} bytes`);
                    if (!mainModelFile && (file.name.toLowerCase().endsWith('.gltf') || file.name.toLowerCase().endsWith('.glb'))) {
                        mainModelFile = file;
                    }
                } else if (entry.isDirectory) {
                    const directoryReader = entry.createReader();
                    const entries = await new Promise(resolve => directoryReader.readEntries(resolve));
                    console.log(`[Drop Handler] Reading directory: ${path ? `${path}/${entry.name}` : entry.name}, Entries found: ${entries.length}`);
                    for (const subEntry of entries) {
                        await readDroppedFiles(subEntry, path ? `${path}/${entry.name}` : entry.name);
                    }
                }
            }

            if (e.dataTransfer.items && e.dataTransfer.items.length > 0 && e.dataTransfer.items[0].webkitGetAsEntry) {
                console.log("[Drop Handler] Using webkitGetAsEntry for folder drop detection.");
                for (let i = 0; i < e.dataTransfer.items.length; i++) {
                    const item = e.dataTransfer.items[i];
                    const entry = item.webkitGetAsEntry();
                    if (entry) {
                        await readDroppedFiles(entry, '');
                    }
                }
            } else {
                console.log("[Drop Handler] Falling back to flat file drop (webkitGetAsEntry not available or not a folder drop).");
                for (let i = 0; i < e.dataTransfer.files.length; i++) {
                    const file = e.dataTransfer.files[i];
                    droppedFileBlobs.set(file.name, file);
                    console.log(`[Drop Handler] Stored file (flat): ${file.name}, Type: ${file.type}, Size: ${file.size} bytes`);
                    if (!mainModelFile && (file.name.toLowerCase().endsWith('.gltf') || file.name.toLowerCase().endsWith('.glb'))) {
                        mainModelFile = file;
                    }
                }
            }

            if (mainModelFile) {
                uploadedFile = mainModelFile;
                console.log("[Drop Handler] Identified main model file:", uploadedFile.name);
                if (validateFile(uploadedFile)) {
                    // If already in editor, load the model directly
                    if (editorPage.classList.contains('page-active')) {
                        loadModel(uploadedFile);
                    } else {
                        // On upload page, just validate and then go to editor with the uploaded file
                        loadingMsg.textContent = `File selected: ${uploadedFile.name}. Loading editor...`;
                        loadingMsg.style.color = '#007bff';
                        loadingMsg.style.display = 'block';
                        goToEditor('uploaded');
                    }
                }
                console.log("[Drop Handler] All dropped files (keys in map):", Array.from(droppedFileBlobs.keys()));
            } else {
                loadingMsg.textContent = '❌ No .gltf or .glb file found among dropped items!';
                loadingMsg.style.color = 'red';
                loadingMsg.style.display = 'block';
                uploadedFile = null;
                setTimeout(() => { // Hide message after a delay
                    loadingMsg.style.display = 'none';
                    loadingMsg.textContent = '';
                }, 3000);
            }
            console.log("[Drop Handler] uploadedFile after drop processing:", uploadedFile ? uploadedFile.name : "null");
        });

        fileInput.addEventListener('change', () => {
            console.log("[File Input] Change event detected. Files:", fileInput.files);

            // Always ensure dropZone is hidden and non-interactive when file dialog closes
            dropZone.style.display = 'none';
            dropZone.style.pointerEvents = 'none';
            loadingMsg.style.display = 'none'; // Hide any previous loading message
            loadingMsg.textContent = ''; // Clear previous message

            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                uploadedFile = file;
                console.log("[File Input] Selected file:", uploadedFile.name, `Type: ${uploadedFile.type}, Size: ${uploadedFile.size} bytes`);

                if (validateFile(uploadedFile)) {
                    loadingMsg.textContent = `Processing selected file: ${uploadedFile.name}...`;
                    loadingMsg.style.color = '#007bff';
                    loadingMsg.style.display = 'block'; // Show loading message *only* if a file is valid

                    droppedFileBlobs.clear(); // Clear previous context
                    droppedFileBlobs.set(file.name, file); // Store the selected file

                    if (editorPage.classList.contains('page-active')) {
                        loadModel(uploadedFile);
                    } else {
                        loadingMsg.textContent = `File selected: ${uploadedFile.name}. Loading editor...`;
                        loadingMsg.style.color = '#007bff';
                        loadingMsg.style.display = 'block';
                        goToEditor('uploaded');
                    }
                } else {
                    // Validation failed, message already set by validateFile
                    setTimeout(() => { // Hide message after a delay
                        loadingMsg.style.display = 'none';
                        loadingMsg.textContent = '';
                    }, 3000);
                }
            } else {
                console.log("[File Input] No file selected via input (e.g., dialog cancelled or no file chosen).");
                uploadedFile = null;
                // No need to show a message if nothing was selected, just clear any previous ones.
                // loadingMsg.textContent = 'No file selected.';
                // loadingMsg.style.color = 'orange';
                // loadingMsg.style.display = 'block';
                // setTimeout(() => {
                //     loadingMsg.style.display = 'none';
                //     loadingMsg.textContent = '';
                // }, 3000);
            }
            console.log("[File Input] uploadedFile after change processing:", uploadedFile ? uploadedFile.name : "null");
        });

        function validateFile(file) {
            console.log("[Validation] Validating file:", file ? file.name : "null");
            if (file && (file.name.toLowerCase().endsWith('.gltf') || file.name.toLowerCase().endsWith('.glb'))) {
                console.log("[Validation] File is a valid GLTF/GLB.");
                return true;
            } else {
                console.error("[Validation] Unsupported file type! Please upload a .gltf or .glb file.");
                // Set message for the caller to display/hide
                loadingMsg.textContent = '❌ Unsupported file type! Please upload a .gltf or .glb file.';
                loadingMsg.style.color = 'red';
                uploadedFile = null;
                return false;
            }
        }

        function disposeSceneResources() {
            console.log("[Dispose] Disposing Three.js resources...");
            if (scene) {
                // Remove all loaded models and dispose their resources
                loadedModels.forEach(model => {
                    scene.remove(model);
                    model.traverse(function (object) {
                        if (object.isMesh) {
                            if (object.geometry) object.geometry.dispose();
                            if (object.material) {
                                if (Array.isArray(object.material)) {
                                    object.material.forEach(mat => mat.dispose());
                                } else {
                                    object.material.dispose();
                                }
                            }
                        }
                    });
                });
                loadedModels = []; // Clear the array of loaded models

                // Remove grid helper and labels specifically if they exist
                if (currentGridHelper) {
                    scene.remove(currentGridHelper);
                    currentGridHelper.geometry.dispose();
                    currentGridHelper.material.dispose();
                    currentGridHelper = null;
                }
                currentGridLabels.forEach(label => {
                    scene.remove(label);
                    if (label.material) label.material.dispose();
                    if (label.geometry) label.geometry.dispose();
                });
                currentGridLabels = [];

                // Dispose renderer and controls only if they exist
                if (renderer) {
                    renderer.setAnimationLoop(null);
                    renderer.dispose();
                    renderer = null;
                }
                if (controls) {
                    controls.removeEventListener('change', updateDynamicGrid); // Remove listener
                    controls.dispose();
                    controls = null;
                }
                if (cadCanvas) {
                    cadCanvas.removeEventListener('mousedown', onCanvasClick, false);
                    cadCanvas.removeEventListener('touchstart', onCanvasClick, false);
                }
                if (transformControls) {
                    transformControls.dispose();
                    transformControls = null;
                }
                // Dispose view axes helper and its scene/camera/renderer only if they exist
                if (viewAxesHelper) {
                    // Iterate through children of viewAxesHelper (the axis meshes)
                    viewAxesHelper.children.forEach(child => {
                        if (child.isMesh) {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => mat.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        }
                    });
                    viewAxesScene.remove(viewAxesHelper); // Remove the group itself
                    viewAxesHelper = null;
                }
                if (viewAxesRenderer) {
                    viewAxesRenderer.setAnimationLoop(null);
                    viewAxesRenderer.dispose();
                    viewAxesRenderer = null;
                }
                if (viewAxesCamera) {
                    viewAxesCamera = null;
                }
                // Clear the container for the view axes helper
                if (viewAxesContainer) {
                    viewAxesContainer.innerHTML = '';
                }

                // Re-initialize scene after disposal to ensure a clean state
                initScene();
            }
            originalMaterialProperties.clear(); // Clear original material properties map
            selectedObject = null; // Clear selected object
            console.log("[Dispose] Resources disposed and scene re-initialized.");
        }


        function goToEditor(loadType = 'empty') { // Default to 'empty' if no type specified
            console.log(`[goToEditor] Function called with load type: ${loadType}.`); // Added log

            // Dispose and re-init scene to ensure a clean state for new or loaded models
            disposeSceneResources();

            if (loadType === 'random') {
                console.log("[goToEditor] Loading a random model.");
                loadRandomModel();
                addMessageToLog('System', 'Loading a random model. Use "Upload New File" to add more models.');
                speakResponse('Loading a random model. You can upload files from the editor.');
            } else if (loadType === 'empty') {
                console.log("[goToEditor] Creating an empty model scene.");
                addMessageToLog('System', 'Starting a new, empty model. Use "Upload New File" to load models.');
                speakResponse('Starting a new, empty model. You can upload files from the editor.');
                // No model loading needed for empty scene, just initScene() handles the grid.
            } else if (loadType === 'uploaded' && uploadedFile) {
                loadingMsg.textContent = `Loading model: ${uploadedFile.name}...`;
                loadingMsg.style.color = '#007bff';
                loadingMsg.style.display = 'block';
                console.log(`[goToEditor] Transitioning to editor. Preparing to load uploaded model: ${uploadedFile.name}`);
                console.log(`[goToEditor] Current droppedFileBlobs keys:`, Array.from(droppedFileBlobs.keys()));
                loadModel(uploadedFile);
            } else {
                console.warn("[goToEditor] Invalid loadType or no uploadedFile for 'uploaded' type. Defaulting to empty scene.");
                addMessageToLog('System', 'Invalid load request. Starting with an empty scene.');
                speakResponse('Invalid load request. Starting with an empty scene.');
            }

            uploadPage.classList.remove('page-active');
            uploadPage.classList.add('page-inactive');

            editorPage.classList.remove('page-inactive');
            editorPage.classList.add('page-active');
            console.log("[goToEditor] Page transition complete. Editor page is now active."); // Added log
        }

        function loadRandomModel() {
            const randomIndex = Math.floor(Math.random() * RANDOM_MODEL_URLS.length);
            const modelUrl = RANDOM_MODEL_URLS[randomIndex];
            console.log(`[loadRandomModel] Attempting to load random model from URL: ${modelUrl}`); // Added log
            const loader = new GLTFLoader();
            loader.load(modelUrl, (gltf) => {
                const randomModel = gltf.scene;
                randomModel.name = `Random Model (${modelUrl.split('/').pop()})`;
                scene.add(randomModel);
                loadedModels.push(randomModel);
                resetView();
                addMessageToLog('System', `Random model "${randomModel.name}" loaded successfully.`);
                speakResponse(`Random model loaded.`);
                console.log(`[loadRandomModel] Random model "${randomModel.name}" loaded successfully.`); // Added log
            }, undefined, (error) => {
                console.error('Error loading random model:', error);
                addMessageToLog('System', `Error loading random model from ${modelUrl}. Starting with an empty scene.`);
                speakResponse(`Error loading random model. Starting with an empty scene.`);
                console.error(`[loadRandomModel] Error loading random model from ${modelUrl}:`, error); // Added log
            });
        }


        function goBack() {
            console.log("[Navigation] Going back to upload page.");
            editorPage.classList.remove('page-active');
            editorPage.classList.add('page-inactive');
            uploadPage.classList.remove('page-inactive');
            uploadPage.classList.add('page-active');
            stopVoiceAssist();
            window.removeEventListener('resize', onWindowResize, false);
            disposeSceneResources(); // This will clear all models and re-initialize the scene
            uploadedFile = null;
            droppedFileBlobs.clear();
            originalMaterialProperties.clear(); // Clear this map too
            selectedObject = null;
            fileInput.value = ''; // Clear file input value
            loadingMsg.textContent = 'Drag and Drop your .gltf or .glb file(s) here, or click to browse.';
            loadingMsg.style.display = 'none';
            loadingMsg.style.color = '';
            dropZone.textContent = 'Drag and Drop your .gltf or .glb file(s) here';
            dropZone.style.borderColor = '#a0aec0';
            // Hide dropZone and loadingMsg when returning to the upload page
            dropZone.style.display = 'none';
            dropZone.style.pointerEvents = 'none';
            loadingMsg.style.display = 'none';
            console.log("[Navigation] Returned to upload page. State reset.");
            addMessageToLog('System', 'Welcome back! Choose an option to get started.');
        }

        // --- Three.js Scene Setup and Model Loading ---
        function initScene() {
            console.log("[initScene] Initializing Three.js scene...");
            if (typeof THREE === 'undefined') {
                console.error("THREE is not defined at initScene! Three.js script might not have loaded or executed correctly.");
                addMessageToLog('System', "Error: Three.js library failed to load. Please check console for details.");
                return;
            }
            // Only create new scene, renderer, camera, controls if they don't exist
            if (!scene) {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xFFFFFF); // Pure white background
            }
            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ canvas: cadCanvas, antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.xr.enabled = true;
            }
            if (!camera) {
                const viewerDiv = cadCanvas.parentElement;
                camera = new THREE.PerspectiveCamera(75, viewerDiv.clientWidth / viewerDiv.clientHeight, 0.1, 1000);
                // Adjusted initial camera position for a more "twisted" or perspective view
                camera.position.set(30, 30, 30); // Set camera at an angle
            }
            if (!controls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.addEventListener('change', updateDynamicGrid); // Call on camera change
                controls.target.set(0, 0, 0); // Ensure controls target the origin
            }
            if (!transformControls) {
                transformControls = new TransformControls(camera, renderer.domElement);
                scene.add(transformControls);
                transformControls.addEventListener('dragging-changed', function (event) {
                    controls.enabled = !event.value;
                });
            }

            // Ensure renderer size is correct on init/re-init
            const viewerDiv = cadCanvas.parentElement;
            renderer.setSize(viewerDiv.clientWidth, viewerDiv.clientHeight);
            camera.aspect = viewerDiv.clientWidth / viewerDiv.clientHeight;
            camera.updateProjectionMatrix();


            // Call updateDynamicGrid initially to set up the first grid
            updateDynamicGrid();

            // Increased lighting for better visibility
            // Remove existing lights before adding new ones to prevent duplicates on re-init
            scene.children.filter(c => c.isLight).forEach(light => scene.remove(light));

            const ambientLight = new THREE.AmbientLight(0x808080); // Brighter ambient light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Full intensity directional light
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.7); // Additional light from another angle
            directionalLight2.position.set(-1, -1, -1).normalize();
            scene.add(directionalLight2);


            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            // Remove previous listeners before adding new ones to prevent duplicates on re-init
            cadCanvas.removeEventListener('mousedown', onCanvasClick, false);
            cadCanvas.removeEventListener('touchstart', onCanvasClick, false);
            cadCanvas.addEventListener('mousedown', onCanvasClick, false);
            cadCanvas.addEventListener('touchstart', onCanvasClick, false);

            initViewAxesHelper(); // Initialize the static view axes helper
            console.log("[initScene] Three.js scene initialized.");
            animate();
        }

        // Function to create a text sprite
        function makeTextSprite(message, parameters) {
            if (parameters === undefined) parameters = {};
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 40;
            const borderThickness = 0; // Removed border
            const borderColor = parameters.borderColor || { r: 0, g: 0, b: 0, a: 0.0 }; // Transparent border
            const backgroundColor = parameters.backgroundColor || { r: 255, g: 255, b: 255, a: 0.0 }; // Transparent background
            const textColor = parameters.textColor || { r: 0, g: 0, b: 0, a: 1.0 };

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = "Bold " + fontsize + "px " + fontface;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;

            // Adjust canvas size to fit text
            canvas.width = textWidth + borderThickness * 2;
            canvas.height = fontsize + borderThickness * 2;

            context.font = "Bold " + fontsize + "px " + fontface;
            context.textBaseline = "middle"; // Center vertically
            context.textAlign = "center";   // Center horizontally

            // background color (if not transparent)
            if (backgroundColor.a > 0) {
                context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
                context.fillRect(0, 0, canvas.width, canvas.height);
            }

            context.fillStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", " + textColor.a + ")";
            context.fillText(message, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.userData.isGridLabel = true; // Mark as grid label for easy removal
            return sprite;
        }

        function updateDynamicGrid() {
            // Clear existing grid and labels
            if (currentGridHelper) {
                scene.remove(currentGridHelper);
                currentGridHelper.geometry.dispose();
                currentGridHelper.material.dispose();
                currentGridHelper = null;
            }
            currentGridLabels.forEach(label => {
                scene.remove(label);
                if (label.material) label.material.dispose();
                if (label.geometry) label.geometry.dispose();
            });
            currentGridLabels = [];

            // Calculate distance to the center of the orbit (controls.target is usually 0,0,0)
            const distance = camera.position.distanceTo(controls.target);

            let gridSize, divisions, labelInterval, labelFontSize, labelScaleFactor;
            let gridLineColor = 0xbbbbbb; // Light grey for grid lines
            let centerLineColor = 0x888888; // Slightly darker for center lines
            // Very light grey for "less bright" effect on pure white background
            let labelTextColor = { r: 180, g: 180, b: 180, a: 1.0 };

            // Define grid levels based on camera distance
            // Further reduced labelScaleFactor and labelFontSize for all levels
            if (distance < 5) { // Very close zoom
                gridSize = 20;
                divisions = 20; // 1 unit per division
                labelInterval = 2; // Labels every 2 units
                labelFontSize = 10; // Very small base font size
                labelScaleFactor = 0.02; // Very small scale factor
            } else if (distance < 20) { // Close zoom
                gridSize = 50;
                divisions = 25; // 2 units per division
                labelInterval = 5; // Labels every 5 units
                labelFontSize = 12; // Very small base font size
                labelScaleFactor = 0.025; // Very small scale factor
            } else if (distance < 80) { // Medium zoom
                gridSize = 100;
                divisions = 20; // 5 units per division
                labelInterval = 10; // Labels every 10 units
                labelFontSize = 14; // Small base font size
                labelScaleFactor = 0.03; // Small scale factor
            } else if (distance < 250) { // Further zoom
                gridSize = 250;
                divisions = 25; // 10 units per division
                labelInterval = 25; // Labels every 25 units
                labelFontSize = 16; // Small base font size
                labelScaleFactor = 0.035; // Small scale factor
            } else if (distance < 600) { // Even further zoom
                gridSize = 600;
                divisions = 30; // 20 units per division
                labelInterval = 50; // Labels every 50 units
                labelFontSize = 18; // Slightly larger base font size
                labelScaleFactor = 0.04; // Slightly larger scale factor
            }
            else { // Very far zoom
                gridSize = 1000;
                divisions = 25; // 40 units per division
                labelInterval = 100; // Labels every 100 units
                labelFontSize = 20; // Slightly larger base font size
                labelScaleFactor = 0.045; // Slightly larger scale factor
            }

            // Create new GridHelper
            const newGridHelper = new THREE.GridHelper(gridSize, divisions, centerLineColor, gridLineColor);
            newGridHelper.material.opacity = 0.2;
            newGridHelper.material.transparent = true;
            newGridHelper.name = 'gridHelper';
            scene.add(newGridHelper);
            currentGridHelper = newGridHelper;

            // Create new labels
            const labelOffset = 0.5; // Kept small and fixed for now
            // Only add labels if the current grid density makes sense for them
            if (labelInterval <= gridSize / 5) { // Arbitrary threshold to avoid too many labels
                for (let i = -gridSize / 2; i <= gridSize / 2; i += labelInterval) {
                    // Skip origin and potentially very small numbers if interval is large
                    if (i === 0 || (labelInterval > 10 && Math.abs(i) < labelInterval)) continue;

                    // X-axis labels
                    const xLabel = makeTextSprite(i.toString(), { textColor: labelTextColor, fontsize: labelFontSize });
                    // Position along Z-edge, adjusted by label size, and slightly offset to prevent overlap with grid lines
                    xLabel.position.set(i, labelOffset, -gridSize / 2 - (labelFontSize * labelScaleFactor * 0.75));
                    xLabel.scale.set(labelFontSize * labelScaleFactor, labelFontSize * labelScaleFactor, 1); // Scale based on font size and factor
                    scene.add(xLabel);
                    currentGridLabels.push(xLabel);

                    // Z-axis labels
                    const zLabel = makeTextSprite(i.toString(), { textColor: labelTextColor, fontsize: labelFontSize });
                    // Position along X-edge, adjusted by label size, and slightly offset
                    zLabel.position.set(-gridSize / 2 - (labelFontSize * labelScaleFactor * 0.75), labelOffset, i);
                    zLabel.scale.set(labelFontSize * labelScaleFactor, labelFontSize * labelScaleFactor, 1);
                    scene.add(zLabel);
                    currentGridLabels.push(zLabel);
                }
            }
        }

        function animate() {
            renderer.setAnimationLoop(() => {
                controls.update();
                renderer.render(scene, camera);
                // Render the static view axes helper scene
                if (viewAxesRenderer && viewAxesScene && viewAxesCamera) {
                     viewAxesRenderer.render(viewAxesScene, viewAxesCamera);
                }
            });
        }

        function loadModel(file) {
            console.log("[loadModel] Attempting to load file:", file.name);
            const loader = new GLTFLoader();
            const fileLoader = new THREE.FileLoader();
            fileLoader.manager = new THREE.LoadingManager();
            fileLoader.manager.setURLModifier(url => {
                console.log(`[URLModifier] Requested URL: "${url}"`);
                const fileName = url.split('/').pop();
                let resolvedPath = fileName;
                if (url.startsWith('blob:')) {
                    const blobFile = Array.from(droppedFileBlobs.values()).find(f => URL.createObjectURL(f) === url);
                    if (blobFile) {
                        resolvedPath = blobFile.name;
                        console.log(`[URLModifier] Resolved blob URL to file: ${resolvedPath}`);
                    }
                } else {
                    const potentialPaths = Array.from(droppedFileBlobs.keys()).filter(key => key.endsWith(fileName));
                    if (potentialPaths.length > 0) {
                        potentialPaths.sort((a, b) => a.length - b.length)[0]; // Use the shortest path if multiple
                        resolvedPath = potentialPaths.sort((a, b) => a.length - b.length)[0];
                        console.log(`[URLModifier] Resolved relative path to: ${resolvedPath}`);
                    }
                }
                const foundFile = droppedFileBlobs.get(resolvedPath);
                if (foundFile) {
                    const blobURL = URL.createObjectURL(foundFile);
                    console.log(`[URLModifier] Returning Blob URL for ${resolvedPath}: ${blobURL}`);
                    return blobURL;
                } else {
                    console.warn(`[URLModifier] GLTFLoader could not find referenced file: "${url}" (tried "${resolvedPath}", and potentially combined paths). Falling back to original URL.`);
                    return url;
                }
            });
            const reader = new FileReader();
            reader.onload = (event) => {
                const contents = event.target.result;
                console.log(`[FileReader] ${file.name} read successfully.`);
                loader.manager = fileLoader.manager;
                loader.parse(contents, '', (gltf) => {
                    console.log("[GLTFLoader] .gltf/.glb parsing successful.");

                    const newModel = gltf.scene;
                    newModel.name = file.name; // Assign the file name to the model for identification
                    scene.add(newModel); // Add the new model to the scene

                    loadedModels.push(newModel); // Store the new model in our array

                    console.log(`[loadModel] Model '${file.name}' added to scene. Total models: ${loadedModels.length}`);
                    console.log("[loadModel] New model bounding box:", new THREE.Box3().setFromObject(newModel));

                    // Call resetView to adjust camera and controls to fit all loaded models
                    resetView();

                    loadingMsg.style.display = 'none';
                    addMessageToLog('System', `Model '${file.name}' loaded successfully. Total models: ${loadedModels.length}`);
                    speakResponse(`Model loaded successfully. You now have ${loadedModels.length} models in the scene.`);
                    console.log("[loadModel] Model successfully added to scene. Current loadedModels:", loadedModels);
                }, (xhr) => {
                    loadingMsg.textContent = `Loading ${file.name}: ${Math.round(xhr.loaded / xhr.total * 100)}%`;
                }, (error) => {
                    console.error('An error happened loading the GLTF model:', error);
                    addMessageToLog('System', 'Error loading model. Please ensure it\'s a valid .gltf or .glb file and all associated files (like textures) are in the same folder if dropped as a folder, or embedded within the .glb.');
                    speakResponse(`Error loading model. Please check the console for details.`);
                    loadingMsg.textContent = '❌ Error loading model!';
                    loadingMsg.style.color = 'red';
                });
            };
            reader.readAsArrayBuffer(file);
        }

        // --- Model Interaction (Selection, Transformation, Information) ---
        let mouseDownX = 0;
        let mouseDownY = 0;
        const CLICK_TOLERANCE = 3; // Max pixels difference for a click to be registered

        function onCanvasClick(event) {
            // Only process left-click (mouse button 0) or touchstart
            if (event.type === 'mousedown' && event.button !== 0) return;

            // If TransformControls are currently active and dragging, do not process selection
            if (transformControls && transformControls.dragging) {
                console.log("[onCanvasClick] TransformControls are dragging, skipping selection.");
                return;
            }

            // Store initial pointer position on mousedown/touchstart
            if (event.type === 'touchstart') {
                mouseDownX = event.touches[0].clientX;
                mouseDownY = event.touches[0].clientY;
            } else {
                mouseDownX = event.clientX;
                mouseDownY = event.clientY;
            }
            console.log(`[onCanvasClick] Mouse/Touch Down: Initial(${mouseDownX}, ${mouseDownY})`);

            // Add a temporary mouseup/touchend listener to check for drag vs click
            const onPointerUp = (upEvent) => {
                let currentX, currentY;
                if (upEvent.type === 'touchend') {
                    // For touchend, use changedTouches as touches array might be empty
                    if (upEvent.changedTouches && upEvent.changedTouches.length > 0) {
                        currentX = upEvent.changedTouches[0].clientX;
                        currentY = upEvent.changedTouches[0].clientY;
                    } else {
                        // Fallback if changedTouches is also empty (unlikely but safe)
                        currentX = mouseDownX;
                        currentY = mouseDownY;
                    }
                } else {
                    currentX = upEvent.clientX;
                    currentY = upEvent.clientY;
                }

                const deltaX = Math.abs(mouseDownX - currentX);
                const deltaY = Math.abs(mouseDownY - currentY);

                console.log(`[onCanvasClick] Mouse/Touch Up: Final(${currentX}, ${currentY}). DeltaX=${deltaX}, DeltaY=${deltaY}. Tolerance=${CLICK_TOLERANCE}`);

                if (deltaX > CLICK_TOLERANCE || deltaY > CLICK_TOLERANCE) {
                    console.log("[onCanvasClick] Detected drag (movement exceeded tolerance), skipping selection.");
                } else {
                    // It was a click, proceed with raycasting
                    console.log("[onCanvasClick] Detected click (movement within tolerance), processing selection.");
                    // Normalize mouse coordinates for raycasting using the initial mousedown position
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((mouseDownX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((mouseDownY - rect.top) / rect.height) * 2 + 1;

                    raycaster.setFromCamera(mouse, camera);

                    const objectsToIntersect = [];
                    loadedModels.forEach(modelGroup => { // Iterate through each loaded model group
                        modelGroup.traverse((obj) => {
                            if (obj.isMesh && !obj.userData.isGridLabel) { // Exclude grid labels
                                objectsToIntersect.push(obj);
                            }
                        });
                    });

                    const intersects = raycaster.intersectObjects(objectsToIntersect, true);

                    if (intersects.length > 0) {
                        const intersectedObject = intersects[0].object;
                        console.log("[onCanvasClick] Object intersected:", intersectedObject.name || "Unnamed Object", intersectedObject.uuid);
                        selectObject(intersectedObject);
                    } else {
                        console.log("[onCanvasClick] No object intersected.");
                        clearSelection();
                    }
                }

                // Clean up the temporary listeners
                renderer.domElement.removeEventListener('mouseup', onPointerUp);
                renderer.domElement.removeEventListener('touchend', onPointerUp);
            };

            // Attach temporary listeners for mouseup/touchend
            renderer.domElement.addEventListener('mouseup', onPointerUp, { once: true });
            renderer.domElement.addEventListener('touchend', onPointerUp, { once: true });
        }

        function selectObject(object) {
            console.log(`[selectObject] Attempting to select object: ${object.name || 'Unnamed Object'} (UUID: ${object.uuid})`);

            // If there was a previously selected object, revert its highlight
            if (selectedObject && originalMaterialProperties.has(selectedObject.uuid)) {
                console.log(`[selectObject] Reverting previous selection for: ${selectedObject.name || 'Unnamed Object'} (UUID: ${selectedObject.uuid})`);
                const originalProps = originalMaterialProperties.get(selectedObject.uuid);
                const materials = Array.isArray(selectedObject.material) ? selectedObject.material : [selectedObject.material];
                materials.forEach((mat, index) => {
                    if (mat) {
                        console.log(`[selectObject]   Material ${index}: Before revert - emissive: ${mat.emissive?.getHex()}, color: ${mat.color?.getHex()}`);
                        if (originalProps.hasOwnProperty('emissive')) {
                            mat.emissive.copy(originalProps.emissive);
                            mat.emissiveIntensity = originalProps.emissiveIntensity;
                            console.log(`[selectObject]     Reverted emissive to: ${mat.emissive.getHex()}, intensity: ${mat.emissiveIntensity}`);
                        }
                        if (originalProps.hasOwnProperty('color')) {
                            mat.color.copy(originalProps.color);
                            console.log(`[selectObject]     Reverted color to: ${mat.color.getHex()}`);
                        }
                        mat.needsUpdate = true;
                        console.log(`[selectObject]   Material ${index}: After revert - emissive: ${mat.emissive?.getHex()}, color: ${mat.color?.getHex()}`);
                    }
                });
                originalMaterialProperties.delete(selectedObject.uuid);
            }

            if (object) {
                selectedObject = object;
                const highlightColor = new THREE.Color(0x1e90ff); // Dodger Blue for highlight
                console.log(`[selectObject] Applying highlight to: ${selectedObject.name || 'Unnamed Object'} (UUID: ${selectedObject.uuid}) with color ${highlightColor.getHex()}`);

                const materials = Array.isArray(selectedObject.material) ? selectedObject.material : [selectedObject.material];
                materials.forEach((mat, index) => {
                    if (mat && mat.isMaterial) {
                        console.log(`[selectObject]   Material ${index}: Type: ${mat.type}`);
                        // Store original material properties before modifying
                        const propsToStore = {};
                        if (mat.emissive !== undefined) {
                            propsToStore.emissive = mat.emissive.clone();
                            propsToStore.emissiveIntensity = mat.emissiveIntensity;
                            console.log(`[selectObject]     Storing original emissive: ${mat.emissive.getHex()}, intensity: ${mat.emissiveIntensity}`);
                        }
                        if (mat.color !== undefined) {
                            propsToStore.color = mat.color.clone();
                            console.log(`[selectObject]     Storing original color: ${mat.color.getHex()}`);
                        }
                        originalMaterialProperties.set(selectedObject.uuid, propsToStore);

                        // Apply highlight
                        if (mat.emissive !== undefined) {
                            mat.emissive.copy(highlightColor);
                            mat.emissiveIntensity = 0.5; // Adjust intensity as needed
                            console.log(`[selectObject]     Applied highlight to emissive: ${mat.emissive.getHex()}, intensity: ${mat.emissiveIntensity}`);
                        } else if (mat.color !== undefined) {
                            // If no emissive, change the main color
                            mat.color.copy(highlightColor);
                            console.log(`[selectObject]     Applied highlight to color: ${mat.color.getHex()}`);
                        } else {
                            console.warn(`[selectObject] Material for ${object.name || 'Unnamed Part'} (UUID: ${object.uuid}) does not have an emissive or color property. Highlighting might not be work as expected.`);
                        }
                        mat.needsUpdate = true;
                    } else {
                        console.warn(`[selectObject] Material at index ${index} for object ${object.name || 'Unnamed Part'} is null or not a Three.js Material.`);
                    }
                });

                transformControls.attach(selectedObject);
                addMessageToLog('System', `Selected: ${object.name || 'Unnamed Part'} (UUID: ${object.uuid})`);
                speakResponse(`Selected ${object.name || 'a part'}.`);
            } else {
                console.log("[selectObject] No object provided to selectObject function.");
                clearSelection();
            }
        }

        function clearSelection() {
            console.log("[clearSelection] Attempting to clear selection.");
            if (selectedObject && originalMaterialProperties.has(selectedObject.uuid)) {
                console.log(`[clearSelection] Reverting highlight for: ${selectedObject.name || 'Unnamed Part'} (UUID: ${selectedObject.uuid})`);
                const originalProps = originalMaterialProperties.get(selectedObject.uuid);
                const materials = Array.isArray(selectedObject.material) ? selectedObject.material : [selectedObject.material];
                materials.forEach((mat, index) => {
                    if (mat) {
                        console.log(`[clearSelection]   Material ${index}: Before revert - emissive: ${mat.emissive?.getHex()}, color: ${mat.color?.getHex()}`);
                        if (originalProps.hasOwnProperty('emissive')) {
                            mat.emissive.copy(originalProps.emissive);
                            mat.emissiveIntensity = originalProps.emissiveIntensity;
                            console.log(`[clearSelection]     Reverted emissive to: ${mat.emissive.getHex()}, intensity: ${mat.emissiveIntensity}`);
                        }
                        if (originalProps.hasOwnProperty('color')) {
                            mat.color.copy(originalProps.color);
                            console.log(`[clearSelection]     Reverted color to: ${mat.color.getHex()}`);
                        }
                        mat.needsUpdate = true;
                        console.log(`[clearSelection]   Material ${index}: After revert - emissive: ${mat.emissive?.getHex()}, color: ${mat.color?.getHex()}`);
                    } else {
                        console.warn(`[clearSelection] Material at index ${index} for object ${selectedObject.name || 'Unnamed Part'} is null or not a Three.js Material.`);
                    }
                });
                originalMaterialProperties.delete(selectedObject.uuid);
                selectedObject = null;
            }
            transformControls.detach(); // Detach controls when selection is cleared
            addMessageToLog('System', 'Selection cleared.');
            speakResponse('Selection cleared.');
            console.log("[clearSelection] Selection cleared successfully.");
        }

        function removeObject() {
            if (selectedObject) { // Check if something is selected
                const objectToRemoveName = selectedObject.name || "Unnamed Part";
                const objectToRemoveUUID = selectedObject.uuid;

                // Detach transform controls before removing
                transformControls.detach();

                // Find the parent of the selected object in the scene graph
                let parent = selectedObject.parent;
                if (parent) {
                    parent.remove(selectedObject);
                    // Dispose of its resources (geometry, material, textures)
                    if (selectedObject.geometry) selectedObject.geometry.dispose();
                    if (selectedObject.material) {
                        if (Array.isArray(selectedObject.material)) {
                            selectedObject.material.forEach(material => material.dispose());
                        } else {
                            selectedObject.material.dispose();
                        }
                    }

                    // Also check if the removed object was a top-level loaded model, and remove it from loadedModels array
                    const index = loadedModels.indexOf(selectedObject);
                    if (index > -1) {
                        loadedModels.splice(index, 1);
                        console.log(`[Remove Object] Removed top-level model: ${objectToRemoveName}. Remaining models: ${loadedModels.length}`);
                    } else {
                        console.log(`[Remove Object] Removed object: ${objectToRemoveName} (UUID: ${objectToRemoveUUID})`);
                    }

                    addMessageToLog('AI', `Removed ${objectToRemoveName}.`);
                    speakResponse(`Removed ${objectToRemoveName}.`);
                    selectedObject = null; // Clear selected object after removal
                    resetView(); // Re-adjust view after removing an object
                } else {
                    console.warn(`[Remove Object] Selected object ${objectToRemoveName} has no parent to remove from.`);
                    addMessageToLog('System', `Cannot remove ${objectToRemoveName}: No parent found.`);
                    speakResponse(`Cannot remove that part.`);
                }
            } else {
                addMessageToLog('System', 'No object selected to remove.');
                speakResponse('No object selected to remove.');
            }
        }

        function resetView() {
            if (controls && camera && loadedModels.length > 0) {
                // Calculate bounding box of all loaded models
                const overallBbox = new THREE.Box3();
                loadedModels.forEach(model => {
                    overallBbox.union(new THREE.Box3().setFromObject(model));
                });

                if (overallBbox.isEmpty()) {
                    console.warn("[resetView] Overall bounding box is empty. Cannot reset view.");
                    addMessageToLog('System', 'No visible models to reset view to.');
                    speakResponse('No visible models to reset view to.');
                    return;
                }

                const center = overallBbox.getCenter(new THREE.Vector3());
                const size = overallBbox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                console.log("[resetView] Overall Bounding Box:", overallBbox);
                console.log("[resetView] Center:", center);
                console.log("[resetView] Size:", size);
                console.log("[resetView] Max Dimension:", maxDim);

                // Adjust camera position based on the largest dimension of the combined bounding box
                const fov = camera.fov * (Math.PI / 180);
                const cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

                // Position camera to view the entire scene, slightly offset for perspective
                const newCameraPosition = center.clone().add(new THREE.Vector3(maxDim * 0.8, maxDim * 0.8, maxDim * 0.8)); // Adjusted multiplier for better initial view
                camera.position.copy(newCameraPosition);
                camera.lookAt(center);
                controls.target.copy(center); // Orbit controls should orbit around the center of all models
                controls.update();

                console.log("[resetView] New Camera Position:", camera.position);
                console.log("[resetView] Controls Target:", controls.target);

                addMessageToLog('AI', 'View reset to fit all models.');
                speakResponse('View reset to fit all models.');
            } else if (controls && camera) {
                // If no models loaded, reset to a default empty scene view
                camera.position.set(30, 30, 30); // Reset to the initial perspective view
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.update();
                addMessageToLog('System', 'No models loaded. Resetting to default view.');
                speakResponse('No models loaded. Resetting to default view.');
            } else {
                addMessageToLog('System', 'Three.js components not initialized for view reset.');
                speakResponse('Cannot reset view, editor components not ready.');
            }
        }

        function showDesignInfo() {
            if (loadedModels.length > 0) {
                let info = `Total Models Loaded: ${loadedModels.length}\n`;
                loadedModels.forEach((model, index) => {
                    info += `\nModel ${index + 1} (${model.name || 'Unnamed Model'}):\n`;
                    info += `  Number of Meshes: ${model.children.filter(c => c.isMesh).length}\n`;
                    info += `  Total Objects: ${model.children.length}\n`;
                });

                const sceneBbox = new THREE.Box3().setFromObject(scene);
                const sceneSize = sceneBbox.getSize(new THREE.Vector3());
                info += `\nOverall Scene Bounding Box Size: X=${sceneSize.x.toFixed(2)}, Y=${sceneSize.y.toFixed(2)}, Z=${sceneSize.z.toFixed(2)}\n`;

                addMessageToLog('AI', info);
                speakResponse('Design information displayed for all loaded models.');
            } else {
                addMessageToLog('System', 'No models loaded to show design information.');
                speakResponse('No models loaded.');
            }
        }

        function setTransformMode(mode) {
            if (transformControls) {
                transformControls.setMode(mode);
                addMessageToLog('AI', `Transform mode set to ${mode}.`);
                speakResponse(`Transform mode set to ${mode}.`);
            } else {
                addMessageToLog('System', 'Transform controls not available.');
                speakResponse('Transform controls are not available.');
            }
        }

        function listParts() {
            if (loadedModels.length > 0) {
                let parts = "Parts in loaded models:\n";
                loadedModels.forEach((model, modelIndex) => {
                    parts += `\n--- Model ${modelIndex + 1} (${model.name || 'Unnamed Model'}) ---\n`;
                    let modelHasParts = false;
                    model.traverse(obj => {
                        if (obj.isMesh && obj.name) {
                            parts += `- ${obj.name}\n`;
                            modelHasParts = true;
                        }
                    });
                    if (!modelHasParts) {
                        parts += "No named parts found in this model.\n";
                    }
                });
                addMessageToLog('AI', parts);
                speakResponse('Listed parts in the models.');
            } else {
                addMessageToLog('System', 'No models loaded or no parts to list.');
                speakResponse('No models loaded or no parts to list.');
            }
        }

        function selectPartByName(partName) {
            if (loadedModels.length > 0) {
                let foundObject = null;
                for (const model of loadedModels) {
                    model.traverse((obj) => {
                        if (obj.isMesh && obj.name === partName) {
                            foundObject = obj;
                        }
                    });
                    if (foundObject) break; // Stop searching once found
                }

                if (foundObject) {
                    selectObject(foundObject);
                } else {
                    addMessageToLog('System', `Part "${partName}" not found in any loaded models.`);
                    speakResponse(`Part ${partName} not found.`);
                }
            } else {
                addMessageToLog('System', 'No models loaded to select parts from.');
                speakResponse('No models loaded.');
            }
        }

        // --- Camera View Functions (now including negative axes) ---
        function setCameraView(position, target) {
            if (camera && controls) {
                camera.position.copy(position);
                controls.target.copy(target);
                controls.update(); // Update controls after changing camera position/target
                addMessageToLog('System', `Camera view set to [${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}] looking at [${target.x.toFixed(2)}, ${target.y.toFixed(2)}, ${target.z.toFixed(2)}].`);
            } else {
                addMessageToLog('System', 'Three.js components not initialized for view change.');
            }
        }

        function getSceneCenterAndDistance() {
            const bbox = new THREE.Box3().setFromObject(scene);
            const center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const cameraDistance = maxDim * 1.5; // Adjust as needed for comfortable viewing
            return { center, cameraDistance };
        }

        function setTopView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x, center.y + cameraDistance, center.z), center);
            speakResponse('Switched to top view.');
        }

        function setBottomView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x, center.y - cameraDistance, center.z), center);
            speakResponse('Switched to bottom view.');
        }

        function setFrontView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x, center.y, center.z + cameraDistance), center);
            speakResponse('Switched to front view.');
        }

        function setBackView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x, center.y, center.z - cameraDistance), center);
            speakResponse('Switched to back view.');
        }

        function setRightView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x + cameraDistance, center.y, center.z), center);
            speakResponse('Switched to right view.');
        }

        function setLeftView() {
            const { center, cameraDistance } = getSceneCenterAndDistance();
            setCameraView(new THREE.Vector3(center.x - cameraDistance, center.y, center.z), center);
            speakResponse('Switched to left view.');
        }

        function setIsometricView() {
            // This will be similar to resetView, but explicitly for isometric
            // If models are loaded, it will fit them, otherwise a default isometric
            resetView(); // resetView already provides an isometric-like fit or default
            speakResponse('Switched to isometric view.');
        }

        // --- Static View Axes Helper ---
        let viewAxesRaycaster;
        let viewAxesMouse;
        let viewAxesSceneRendered = false; // Flag to ensure it's rendered only once

        function initViewAxesHelper() {
            if (viewAxesSceneRendered) return; // Prevent re-initialization

            viewAxesScene = new THREE.Scene();
            viewAxesCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 10); // Small FOV, aspect 1:1 for container
            viewAxesCamera.position.set(1.5, 1.5, 1.5); // Fixed position for isometric view of axes
            viewAxesCamera.lookAt(0, 0, 0);

            viewAxesRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha true for transparent background
            viewAxesRenderer.setPixelRatio(window.devicePixelRatio);
            viewAxesRenderer.setSize(viewAxesContainer.clientWidth, viewAxesContainer.clientHeight);
            viewAxesRenderer.domElement.style.width = '100%';
            viewAxesRenderer.domElement.style.height = '100%';
            viewAxesContainer.appendChild(viewAxesRenderer.domElement);

            // Create a custom AxesHelper with clickable parts
            viewAxesHelper = new THREE.Group();
            const axisLength = 1.0;
            const axisRadius = 0.08; // Made axes thicker for easier clicking
            const arrowLength = 0.2;
            const arrowRadius = 0.08;

            // X-axis (Red)
            const xAxisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const xAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), xAxisMaterial);
            xAxisCylinder.rotation.z = -Math.PI / 2;
            xAxisCylinder.position.x = axisLength / 2;
            xAxisCylinder.userData.axis = 'x';
            xAxisCylinder.userData.direction = 'positive';
            viewAxesHelper.add(xAxisCylinder);

            const negXAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), xAxisMaterial);
            negXAxisCylinder.rotation.z = Math.PI / 2;
            negXAxisCylinder.position.x = -axisLength / 2;
            negXAxisCylinder.userData.axis = 'x';
            negXAxisCylinder.userData.direction = 'negative';
            viewAxesHelper.add(negXAxisCylinder);

            // Y-axis (Green)
            const yAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const yAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), yAxisMaterial);
            yAxisCylinder.position.y = axisLength / 2;
            yAxisCylinder.userData.axis = 'y';
            yAxisCylinder.userData.direction = 'positive';
            viewAxesHelper.add(yAxisCylinder);

            const negYAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), yAxisMaterial);
            negYAxisCylinder.rotation.z = Math.PI; // Rotate to point downwards
            negYAxisCylinder.position.y = -axisLength / 2;
            negYAxisCylinder.userData.axis = 'y';
            negYAxisCylinder.userData.direction = 'negative';
            viewAxesHelper.add(negYAxisCylinder);

            // Z-axis (Blue)
            const zAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const zAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), zAxisMaterial);
            zAxisCylinder.rotation.x = Math.PI / 2;
            zAxisCylinder.position.z = axisLength / 2;
            zAxisCylinder.userData.axis = 'z';
            zAxisCylinder.userData.direction = 'positive';
            viewAxesHelper.add(zAxisCylinder);

            const negZAxisCylinder = new THREE.Mesh(new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8), zAxisMaterial);
            negZAxisCylinder.rotation.x = -Math.PI / 2;
            negZAxisCylinder.position.z = -axisLength / 2;
            negZAxisCylinder.userData.axis = 'z';
            negZAxisCylinder.userData.direction = 'negative';
            viewAxesHelper.add(negZAxisCylinder);

            viewAxesScene.add(viewAxesHelper);

            // Add labels (X, Y, Z)
            const labelScale = 0.2; // Adjust label size
            const labelOffset = 0.7; // Offset from axis end

            const xLabel = makeTextSprite('X', { textColor: { r: 255, g: 0, b: 0, a: 1.0 }, fontsize: 60 });
            xLabel.position.set(axisLength + labelOffset, 0, 0);
            xLabel.scale.set(labelScale, labelScale, 1);
            viewAxesScene.add(xLabel);

            const yLabel = makeTextSprite('Y', { textColor: { r: 0, g: 255, b: 0, a: 1.0 }, fontsize: 60 });
            yLabel.position.set(0, axisLength + labelOffset, 0);
            yLabel.scale.set(labelScale, labelScale, 1);
            viewAxesScene.add(yLabel);

            const zLabel = makeTextSprite('Z', { textColor: { r: 0, g: 0, b: 255, a: 1.0 }, fontsize: 60 });
            zLabel.position.set(0, 0, axisLength + labelOffset);
            zLabel.scale.set(labelScale, labelScale, 1);
            viewAxesScene.add(zLabel);


            viewAxesRaycaster = new THREE.Raycaster();
            viewAxesMouse = new THREE.Vector2();

            viewAxesContainer.addEventListener('click', onViewAxesClick, false);

            viewAxesSceneRendered = true;
        }

        function onViewAxesClick(event) {
            event.preventDefault(); // Prevent default browser behavior

            // Calculate mouse position in normalized device coordinates (NDC)
            // (-1 to +1) for both X and Y
            const rect = viewAxesRenderer.domElement.getBoundingClientRect();
            viewAxesMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            viewAxesMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            viewAxesRaycaster.setFromCamera(viewAxesMouse, viewAxesCamera);

            // Check for intersections with the individual axis meshes
            const intersects = viewAxesRaycaster.intersectObjects(viewAxesHelper.children, true);

            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                const axis = intersectedObject.userData.axis;
                const direction = intersectedObject.userData.direction;

                console.log(`[ViewAxesClick] Clicked on ${direction} ${axis}-axis.`);
                addMessageToLog('System', `View axis clicked: ${direction} ${axis}-axis.`);

                // Temporary visual feedback on the container
                viewAxesContainer.style.backgroundColor = '#DAA520'; // Accent yellow
                setTimeout(() => {
                    viewAxesContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.3)'; // Revert to original gray
                }, 200); // Flash for 200ms

                // Map to corresponding view functions
                if (axis === 'x') {
                    if (direction === 'positive') setRightView();
                    else setLeftView();
                } else if (axis === 'y') {
                    if (direction === 'positive') setTopView();
                    else setBottomView();
                } else if (axis === 'z') {
                    if (direction === 'positive') setFrontView();
                    else setBackView();
                }
            } else {
                console.log("[ViewAxesClick] No axis clicked. Falling back to Isometric view.");
                addMessageToLog('System', 'View axes helper clicked, but no specific axis. Resetting to Isometric view.');
                setIsometricView(); // If clicked anywhere on the helper but not an axis, go isometric
            }
        }


        // --- AI Chat and Voice Commands ---
        function addMessageToLog(sender, message) {
            const messageElement = document.createElement('p');
            messageElement.classList.add(sender === 'User' ? 'user-message' : sender === 'AI' ? 'ai-response' : 'system-message');
            messageElement.textContent = `${sender}: ${message}`;
            aiLog.appendChild(messageElement);
            aiLog.scrollTop = aiLog.scrollHeight; // Auto-scroll to bottom
        }

        // --- Backend API Configuration ---
        // This URL should point to your Render backend's AI proxy endpoint.
        const BACKEND_API_URL = "https://mingyu.onrender.com/api/ai"; // YOUR RENDER BACKEND URL HERE

        async function sendAICommand(command) {
            sendTextCommandBtn.disabled = true;
            textCommandInput.disabled = true;
            addMessageToLog('System', 'AI is thinking...');
            console.log("[sendAICommand] Sending command to Render backend:", command);

            const payload = {
                prompt: command // Sending the command as 'prompt' to your backend
            };

            try {
                console.log("[sendAICommand] Fetching from backend API:", BACKEND_API_URL, "with payload:", payload);
                const response = await fetch(BACKEND_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                        // No Authorization header here, as the backend handles the OpenAI API key
                    },
                    body: JSON.stringify(payload)
                });

                console.log("[sendAICommand] Backend API response received. Status:", response.status, "OK:", response.ok);

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("[sendAICommand] Backend API Response not OK. Status:", response.status, "Status Text:", response.statusText, "Error Data:", errorData);
                    throw new Error(`Backend API error: ${errorData.error || response.statusText}. Details: ${JSON.stringify(errorData)}`);
                }

                const result = await response.json();
                console.log("[sendAICommand] Raw backend response result:", result);

                if (result.content) { // Expecting { content: "..." } from your backend
                    processAICommand(result.content); // Pass the AI's content for parsing
                } else {
                    console.error("[sendAICommand] Backend response format unexpected or empty. Result:", result);
                    throw new Error("Backend response format unexpected or empty.");
                }

            } catch (error) {
                console.error("Error communicating with backend API:", error);
                addMessageToLog('AI', `I'm sorry, I couldn't reach the AI service through your backend. Please ensure your Render backend is running and configured correctly. Error: ${error.message}`);
                speakResponse(`I'm sorry, I couldn't reach the AI service.`);
            } finally {
                sendTextCommandBtn.disabled = false;
                textCommandInput.disabled = false;
                const lastLogMessage = aiLog.lastChild;
                if (lastLogMessage && lastLogMessage.textContent.includes('AI is thinking...')) {
                    aiLog.removeChild(lastLogMessage);
                }
            }
        }

        // Function to test backend connection on load (now only logs, no UI status update)
        async function testAIConnection() {
            console.log("[testAIConnection] Attempting to test backend connection with a simple 'hello'.");

            try {
                const response = await fetch(BACKEND_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: "hello" })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.content) {
                        console.log(`[testAIConnection] Backend connection successful! AI responded (via backend): "${JSON.parse(result.content).value || 'Hello!'}"`);
                    } else {
                         console.warn('[testAIConnection] Backend responded OK, but AI content was missing or malformed.');
                    }
                } else {
                    const errorData = await response.json();
                    console.error(`[testAIConnection] Backend connection failed: Status ${response.status}. Error: ${errorData.error || response.statusText}. Check Render logs.`);
                }
            } catch (error) {
                console.error(`[testAIConnection] Backend connection failed (network error): ${error.message}. Is your Render server running?`);
            }
        }

        // Function to change the color of the selected object
        function changeObjectColor(colorValue) {
            if (!selectedObject) {
                addMessageToLog('System', 'No object selected. Please select an object first.');
                speakResponse('No object selected. Please select an object first.');
                return;
            }

            try {
                const newColor = new THREE.Color(colorValue);
                const materials = Array.isArray(selectedObject.material) ? selectedObject.material : [selectedObject.material];

                materials.forEach(material => {
                    if (material && material.isMaterial) {
                        // Crucial: Remove map to ensure solid color is visible
                        if (material.map) {
                            material.map.dispose(); // Dispose of the texture to free memory
                            material.map = null;    // Remove the reference to the texture
                        }
                        if (material.color) {
                            material.color.set(newColor);
                        }
                        // If the material has emissive, ensure it's reset to black when changing main color
                        if (material.emissive !== undefined) {
                             material.emissive.set(0x000000); // Reset emissive to black
                             material.emissiveIntensity = 0; // Reset intensity
                        }
                        material.needsUpdate = true; // Inform Three.js that material properties have changed
                    }
                });

                // IMPORTANT: After changing the color, update the stored original properties
                // This ensures that if the object is deselected and re-selected,
                // the highlight logic uses this new color as its base.
                const updatedProps = {};
                const currentMaterials = Array.isArray(selectedObject.material) ? selectedObject.material : [selectedObject.material];
                currentMaterials.forEach(mat => {
                    if (mat && mat.isMaterial) {
                        if (mat.emissive !== undefined) { // Store current emissive (should be black after reset)
                            updatedProps.emissive = mat.emissive.clone();
                            updatedProps.emissiveIntensity = mat.emissiveIntensity;
                        }
                        if (mat.color !== undefined) { // Store the new color
                            updatedProps.color = mat.color.clone();
                        }
                    }
                });
                originalMaterialProperties.set(selectedObject.uuid, updatedProps);


                addMessageToLog('AI', `Changed color of selected object to ${colorValue}.`);
                speakResponse(`Changed color of selected object.`);
                console.log(`[changeObjectColor] Selected object color changed to ${colorValue}.`);
            } catch (error) {
                console.error("Error setting object color:", error);
                addMessageToLog('System', `Failed to change color. Invalid color value or material issue: ${error.message}`);
                speakResponse(`Failed to change color.`);
            }
        }


        function processAICommand(aiResponseContent) { // Now receives the content string directly
            console.log("[processAICommand] Processing AI command content:", aiResponseContent);

            let parsedResponse;
            try {
                parsedResponse = JSON.parse(aiResponseContent); // Parse the content string
                console.log("[processAICommand] Parsed AI response (JSON):", parsedResponse);

                // Handle cases where 'action' might be missing or is 'conversational'
                if (parsedResponse.action === 'conversational' || (!parsedResponse.action && parsedResponse.value)) {
                    addMessageToLog('AI', parsedResponse.value);
                    speakResponse(parsedResponse.value);
                } else if (typeof parsedResponse.action === 'string') {
                    switch (parsedResponse.action) {
                        case 'removeObject':
                            removeObject();
                            break;
                        case 'resetView':
                            resetView();
                            break;
                        case 'showDesignInfo':
                            showDesignInfo();
                            break;
                        case 'setTransformMode':
                            if (parsedResponse.value) {
                                setTransformMode(parsedResponse.value);
                            } else {
                                addMessageToLog('AI', 'Please specify a transform mode (translate, rotate, scale).');
                                speakResponse('Please specify a transform mode like translate, rotate, or scale.');
                            }
                            break;
                        case 'listParts':
                            listParts();
                            break;
                        case 'selectPart':
                            if (parsedResponse.value) {
                                selectPartByName(parsedResponse.value);
                            } else {
                                addMessageToLog('AI', 'Please specify a part name to select.');
                                speakResponse('Please tell me which part to select.');
                            }
                            break;
                        case 'rotateAxis':
                            if (selectedObject && parsedResponse.value) {
                                const { axis, degrees } = parsedResponse.value;
                                const radians = THREE.MathUtils.degToRad(degrees || 90); // Default to 90 degrees
                                switch (axis) {
                                    case 'x': selectedObject.rotation.x += radians; break;
                                    case 'y': selectedObject.rotation.y += radians; break;
                                    case 'z': selectedObject.rotation.z += radians; break;
                                    default: selectedObject.rotation.y += radians; break; // Default axis
                                }
                                addMessageToLog('AI', `Rotated selected object by ${degrees || 90} degrees around ${axis || 'y'}-axis.`);
                                speakResponse(`Rotated selected object.`);
                            } else {
                                addMessageToLog('System', 'No object selected or invalid rotation command.');
                                speakResponse('No object selected or invalid rotation command.');
                            }
                            break;
                        case 'scale':
                            if (selectedObject && parsedResponse.value) {
                                const factor = parsedResponse.value;
                                selectedObject.scale.multiplyScalar(factor);
                                addMessageToLog('AI', `Scaled selected object by a factor of ${factor}.`);
                                speakResponse(`Scaled selected object.`);
                            } else {
                                addMessageToLog('System', 'No object selected or invalid scale command.');
                                speakResponse('No object selected or invalid scale command.');
                            }
                            break;
                        case 'translate':
                            if (selectedObject && parsedResponse.value) {
                                const { x, y, z } = parsedResponse.value;
                                selectedObject.position.x += (x || 0);
                                selectedObject.position.y += (y || 0);
                                selectedObject.position.z += (z || 0);
                                addMessageToLog('AI', `Moved selected object by X:${x || 0}, Y:${y || 0}, Z:${z || 0}.`);
                                speakResponse(`Moved selected object.`);
                            } else {
                                addMessageToLog('System', 'No object selected or invalid translate command.');
                                speakResponse('No object selected or invalid translate command.');
                            }
                            break;
                        case 'changeColor':
                            if (parsedResponse.value) {
                                changeObjectColor(parsedResponse.value);
                            } else {
                                addMessageToLog('AI', 'Please specify a color value (e.g., "red", "#FF0000").');
                                speakResponse('Please specify a color value.');
                            }
                            break;
                        case 'error':
                            addMessageToLog('AI', parsedResponse.value || 'An unknown error occurred.'); // Use parsedResponse.value for error messages
                            speakResponse(parsedResponse.value || 'An unknown error occurred.');
                            break;
                        default:
                            addMessageToLog('AI', `Understood: "${parsedResponse.action}". However, I don't know how to perform this action.`);
                            speakResponse(`I understand, but I don't know how to perform ${parsedResponse.action}.`);
                    }
                } else if (parsedResponse.message) {
                    // Fallback for direct messages if action is not explicitly handled
                    addMessageToLog('AI', parsedResponse.message);
                    speakResponse(parsedResponse.message);
                } else {
                    addMessageToLog('AI', `Unexpected AI response format: ${aiResponseContent}`);
                    speakResponse('I received an unexpected response.');
                }
            } catch (jsonError) {
                console.error("Failed to parse AI response as JSON:", jsonError, "Raw Response (for parsing error):", aiResponseContent); // Specific log for parsing errors
                addMessageToLog('AI', `I received an uninterpretable response from the AI: "${aiResponseContent.substring(0, 100)}...". Please check the console for full details.`);
                speakResponse('I received an uninterpretable response.');
            }
        }

        // Voice input integration
        if ('webkitSpeechRecognition' in window) {
            recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isVoiceAssistActive = true;
                integratedVoiceBtn.classList.add('active-voice-btn');
                addMessageToLog('System', 'Listening for voice commands...');
            };

            recognition.onresult = (event) => {
                const command = event.results[0][0].transcript;
                addMessageToLog('System', `You said: "${command}"`);
                sendAICommand(command);
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                addMessageToLog('System', `Voice command error: ${event.error}`);
                speakResponse("I didn't catch that. Could you please repeat?");
                integratedVoiceBtn.classList.remove('active-voice-btn');
                isVoiceAssistActive = false;
            };

            recognition.onend = () => {
                integratedVoiceBtn.classList.remove('active-voice-btn');
                isVoiceAssistActive = false;
                addMessageToLog('System', 'Voice command ended.');
            };

            integratedVoiceBtn.addEventListener('click', () => {
                if (isVoiceAssistActive) {
                    stopVoiceAssist();
                } else {
                    startVoiceAssist();
                }
            });
        } else {
            integratedVoiceBtn.style.display = 'none'; // Hide button if API not supported
            addMessageToLog('System', 'Voice recognition not supported in this browser.');
        }

        function startVoiceAssist() {
            if (recognition && !isVoiceAssistActive) {
                recognition.start();
            }
        }

        function stopVoiceAssist() {
            if (recognition && isVoiceAssistActive) {
                recognition.stop();
            }
        }

        // Text-to-speech integration
        if ('speechSynthesis' in window) {
            synth = window.speechSynthesis;
        } else {
            console.warn('Text-to-speech not supported in this browser.');
        }

        function speakResponse(text) {
            if (synth) {
                const utterance = new SpeechSynthesisUtterance(text);
                synth.speak(utterance);
            }
        }

        // Send text command via input field
        sendTextCommandBtn.addEventListener('click', () => {
            const command = textCommandInput.value.trim();
            if (command) {
                addMessageToLog('User', command); // Add user message to log immediately
                sendAICommand(command);
                textCommandInput.value = ''; // Clear input after sending
            }
        });

        // Allow sending command by pressing Enter in the input field
        textCommandInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default Enter key behavior (e.g., new line in textarea)
                sendTextCommandBtn.click();
            }
        });

        // Handle window resizing for Three.js canvas
        function onWindowResize() {
            if (camera && renderer && cadCanvas) {
                const viewerDiv = cadCanvas.parentElement;
                camera.aspect = viewerDiv.clientWidth / viewerDiv.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(viewerDiv.clientWidth, viewerDiv.clientHeight);
                updateDynamicGrid(); // Update grid on resize as well
                // No need to call resetView() here, as it can be jarring on every resize.
                // The user can use the "Fit All" button or AI command.
            }
             // Update viewAxesHelper renderer size on window resize
            if (viewAxesRenderer && viewAxesContainer) {
                viewAxesRenderer.setSize(viewAxesContainer.clientWidth, viewAxesContainer.clientHeight);
                viewAxesCamera.aspect = viewAxesContainer.clientWidth / viewAxesContainer.clientHeight;
                viewAxesCamera.updateProjectionMatrix();
            }
        }

        window.addEventListener('resize', onWindowResize, false);

        // Initialize scene when the window loads
        window.onload = () => {
            initScene();
            // Set initial CSS for the CAD viewer background
            cadViewer.style.backgroundColor = '#FFFFFF';
            cadViewer.style.backgroundImage = 'repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(0,0,0,0.1) 20px), repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(0,0,0,0.1) 20px)';
            cadViewer.style.backgroundSize = '20px 20px';

            // Ensure the upload page is active and editor page is inactive on initial load
            uploadPage.classList.add('page-active');
            uploadPage.classList.remove('page-inactive');
            editorPage.classList.add('page-inactive');
            editorPage.classList.remove('page-active');

            // Explicitly hide dropZone and loadingMsg on initial load
            dropZone.style.display = 'none';
            dropZone.style.pointerEvents = 'none';
            loadingMsg.style.display = 'none';

            // Automatically test AI connection on load
            testAIConnection(); // Still call to log backend status to console

            // Removed event listeners for view control buttons as the HTML is removed
            // topViewBtn.addEventListener('click', setTopView);
            // bottomViewBtn.addEventListener('click', setBottomView);
            // frontViewBtn.addEventListener('click', setFrontView);
            // backViewBtn.addEventListener('click', setBackView);
            // rightViewBtn.addEventListener('click', setRightView);
            // leftViewBtn.addEventListener('click', setLeftView);
            // isometricViewBtn.addEventListener('click', setIsometricView);
            // fitAllViewBtn.addEventListener('click', resetView);

            // Add event listener for object color change
            applyObjectColorBtn.addEventListener('click', () => {
                const color = objectColorPicker.value;
                changeObjectColor(color);
            });

            // Initial message to guide the user on the upload page
            addMessageToLog('System', 'Welcome to the AI VR CAD Editor! Please choose an option above to get started: "Create Empty Model", "Edit Existing Model" (to upload a file), or "Load Random Model".');
        };

    </script>
</body>
</html>
